#![doc = r" This file is automatically generated by executing `cargo build --features generate`."]
#![doc = r""]
#![doc = r" **Make adjustments in `build.rs`, not in this file!**"]
#![allow(clippy::many_single_char_names)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused_unsafe)]
use crate::{bindings::root, PluginContext};
#[doc = r" This is the low-level API access point to all SWELL functions."]
#[doc = r""]
#[doc = r" SWELL is the Simple Windows Emulation Layer and is exposed by REAPER for Linux"]
#[doc = r" and Mac OS X."]
#[doc = r""]
#[doc = r" See [`Reaper`] for details how to use this struct (it's very similar)."]
#[doc = r""]
#[doc = r" [`Reaper`]: struct.Reaper.html"]
#[derive(Copy, Clone, Debug, Default)]
pub struct Swell {
    pub(crate) pointers: SwellFunctionPointers,
    pub(crate) plugin_context: Option<PluginContext>,
}
impl Swell {
    #[doc = r" Loads all available SWELL functions from the given plug-in context."]
    #[doc = r""]
    #[doc = r" Returns a `Swell` instance which allows you to call these functions."]
    #[doc = r""]
    #[doc = r" On Windows, this function will not load any function pointers because"]
    #[doc = r" the methods in this struct delegate to the corresponding Windows functions."]
    #[doc = r""]
    #[doc = r" # Panics"]
    #[doc = r""]
    #[doc = r" If this is Linux and the SWELL function provider is not available, this"]
    #[doc = r" function panics."]
    pub fn load(plugin_context: PluginContext) -> Swell {
        #[cfg(target_family = "windows")]
        {
            Swell {
                pointers: Default::default(),
                plugin_context: Some(plugin_context),
            }
        }
        #[cfg(target_family = "unix")]
        {
            let mut loaded_count = 0;
            let get_func = plugin_context
                .swell_function_provider()
                .expect("SWELL function provider not available");
            let mut pointers = unsafe {
                SwellFunctionPointers {
                    loaded_count: 0,
                    lstrcpyn: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(lstrcpyn)).as_ptr(),
                    )),
                    MulDiv: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(MulDiv)).as_ptr(),
                    )),
                    Sleep: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(Sleep)).as_ptr(),
                    )),
                    GetTickCount: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetTickCount)).as_ptr(),
                    )),
                    GetFileTime: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetFileTime)).as_ptr(),
                    )),
                    WritePrivateProfileString: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WritePrivateProfileString)).as_ptr(),
                    )),
                    GetPrivateProfileString: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetPrivateProfileString)).as_ptr(),
                    )),
                    GetPrivateProfileInt: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetPrivateProfileInt)).as_ptr(),
                    )),
                    GetPrivateProfileStruct: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetPrivateProfileStruct)).as_ptr(),
                    )),
                    WritePrivateProfileStruct: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WritePrivateProfileStruct)).as_ptr(),
                    )),
                    WritePrivateProfileSection: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WritePrivateProfileSection)).as_ptr(),
                    )),
                    GetPrivateProfileSection: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetPrivateProfileSection)).as_ptr(),
                    )),
                    GetModuleFileName: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetModuleFileName)).as_ptr(),
                    )),
                    SWELL_PtInRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_PtInRect)).as_ptr(),
                    )),
                    ShellExecute: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ShellExecute)).as_ptr(),
                    )),
                    MessageBox: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(MessageBox)).as_ptr(),
                    )),
                    BrowseForFiles: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(BrowseForFiles)).as_ptr(),
                    )),
                    BrowseForSaveFile: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(BrowseForSaveFile)).as_ptr(),
                    )),
                    BrowseForDirectory: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(BrowseForDirectory)).as_ptr(),
                    )),
                    BrowseFile_SetTemplate: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(BrowseFile_SetTemplate)).as_ptr(),
                    )),
                    GetDlgItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetDlgItem)).as_ptr(),
                    )),
                    ShowWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ShowWindow)).as_ptr(),
                    )),
                    DestroyWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DestroyWindow)).as_ptr(),
                    )),
                    SWELL_GetGestureInfo: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetGestureInfo)).as_ptr(),
                    )),
                    SWELL_HideApp: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_HideApp)).as_ptr(),
                    )),
                    SetDlgItemText: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetDlgItemText)).as_ptr(),
                    )),
                    SetDlgItemInt: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetDlgItemInt)).as_ptr(),
                    )),
                    GetDlgItemInt: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetDlgItemInt)).as_ptr(),
                    )),
                    GetDlgItemText: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetDlgItemText)).as_ptr(),
                    )),
                    CheckDlgButton: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CheckDlgButton)).as_ptr(),
                    )),
                    IsDlgButtonChecked: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(IsDlgButtonChecked)).as_ptr(),
                    )),
                    EnableWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(EnableWindow)).as_ptr(),
                    )),
                    SetFocus: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetFocus)).as_ptr(),
                    )),
                    GetFocus: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetFocus)).as_ptr(),
                    )),
                    SetForegroundWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetForegroundWindow)).as_ptr(),
                    )),
                    GetForegroundWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetForegroundWindow)).as_ptr(),
                    )),
                    SetCapture: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetCapture)).as_ptr(),
                    )),
                    GetCapture: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetCapture)).as_ptr(),
                    )),
                    ReleaseCapture: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ReleaseCapture)).as_ptr(),
                    )),
                    IsChild: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(IsChild)).as_ptr(),
                    )),
                    GetParent: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetParent)).as_ptr(),
                    )),
                    SetParent: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetParent)).as_ptr(),
                    )),
                    GetWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetWindow)).as_ptr(),
                    )),
                    EnumWindows: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(EnumWindows)).as_ptr(),
                    )),
                    FindWindowEx: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(FindWindowEx)).as_ptr(),
                    )),
                    ClientToScreen: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ClientToScreen)).as_ptr(),
                    )),
                    ScreenToClient: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ScreenToClient)).as_ptr(),
                    )),
                    GetWindowRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetWindowRect)).as_ptr(),
                    )),
                    GetWindowContentViewRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetWindowContentViewRect)).as_ptr(),
                    )),
                    GetClientRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetClientRect)).as_ptr(),
                    )),
                    WindowFromPoint: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WindowFromPoint)).as_ptr(),
                    )),
                    WinOffsetRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WinOffsetRect)).as_ptr(),
                    )),
                    WinSetRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WinSetRect)).as_ptr(),
                    )),
                    WinUnionRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WinUnionRect)).as_ptr(),
                    )),
                    WinIntersectRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WinIntersectRect)).as_ptr(),
                    )),
                    SetWindowPos: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetWindowPos)).as_ptr(),
                    )),
                    SWELL_SetWindowLevel: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetWindowLevel)).as_ptr(),
                    )),
                    InvalidateRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(InvalidateRect)).as_ptr(),
                    )),
                    UpdateWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(UpdateWindow)).as_ptr(),
                    )),
                    GetWindowLong: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetWindowLong)).as_ptr(),
                    )),
                    SetWindowLong: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetWindowLong)).as_ptr(),
                    )),
                    ScrollWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ScrollWindow)).as_ptr(),
                    )),
                    EnumPropsEx: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(EnumPropsEx)).as_ptr(),
                    )),
                    GetProp: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetProp)).as_ptr(),
                    )),
                    SetProp: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetProp)).as_ptr(),
                    )),
                    RemoveProp: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(RemoveProp)).as_ptr(),
                    )),
                    IsWindowVisible: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(IsWindowVisible)).as_ptr(),
                    )),
                    IsWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(IsWindow)).as_ptr(),
                    )),
                    SetTimer: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetTimer)).as_ptr(),
                    )),
                    KillTimer: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(KillTimer)).as_ptr(),
                    )),
                    ListView_SetExtendedListViewStyleEx: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetExtendedListViewStyleEx))
                            .as_ptr(),
                    )),
                    ListView_InsertColumn: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_InsertColumn)).as_ptr(),
                    )),
                    ListView_DeleteColumn: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_DeleteColumn)).as_ptr(),
                    )),
                    ListView_SetColumn: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetColumn)).as_ptr(),
                    )),
                    ListView_GetColumnWidth: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetColumnWidth)).as_ptr(),
                    )),
                    ListView_InsertItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_InsertItem)).as_ptr(),
                    )),
                    ListView_SetItemText: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetItemText)).as_ptr(),
                    )),
                    ListView_SetItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetItem)).as_ptr(),
                    )),
                    ListView_GetNextItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetNextItem)).as_ptr(),
                    )),
                    ListView_GetItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetItem)).as_ptr(),
                    )),
                    ListView_GetItemState: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetItemState)).as_ptr(),
                    )),
                    ListView_DeleteItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_DeleteItem)).as_ptr(),
                    )),
                    ListView_DeleteAllItems: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_DeleteAllItems)).as_ptr(),
                    )),
                    ListView_GetSelectedCount: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetSelectedCount)).as_ptr(),
                    )),
                    ListView_GetItemCount: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetItemCount)).as_ptr(),
                    )),
                    ListView_GetSelectionMark: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetSelectionMark)).as_ptr(),
                    )),
                    ListView_SetColumnWidth: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetColumnWidth)).as_ptr(),
                    )),
                    ListView_SetItemState: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetItemState)).as_ptr(),
                    )),
                    ListView_RedrawItems: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_RedrawItems)).as_ptr(),
                    )),
                    ListView_SetItemCount: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetItemCount)).as_ptr(),
                    )),
                    ListView_EnsureVisible: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_EnsureVisible)).as_ptr(),
                    )),
                    ListView_GetSubItemRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetSubItemRect)).as_ptr(),
                    )),
                    ListView_SetImageList: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetImageList)).as_ptr(),
                    )),
                    ListView_HitTest: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_HitTest)).as_ptr(),
                    )),
                    ListView_SubItemHitTest: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SubItemHitTest)).as_ptr(),
                    )),
                    ListView_GetItemText: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetItemText)).as_ptr(),
                    )),
                    ListView_SortItems: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SortItems)).as_ptr(),
                    )),
                    ListView_GetItemRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetItemRect)).as_ptr(),
                    )),
                    ListView_Scroll: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_Scroll)).as_ptr(),
                    )),
                    ListView_GetTopIndex: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetTopIndex)).as_ptr(),
                    )),
                    ListView_GetCountPerPage: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetCountPerPage)).as_ptr(),
                    )),
                    ListView_SetColumnOrderArray: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetColumnOrderArray)).as_ptr(),
                    )),
                    ListView_GetColumnOrderArray: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetColumnOrderArray)).as_ptr(),
                    )),
                    ListView_GetHeader: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_GetHeader)).as_ptr(),
                    )),
                    Header_GetItemCount: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(Header_GetItemCount)).as_ptr(),
                    )),
                    Header_GetItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(Header_GetItem)).as_ptr(),
                    )),
                    Header_SetItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(Header_SetItem)).as_ptr(),
                    )),
                    SWELL_GetListViewHeaderHeight: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetListViewHeaderHeight)).as_ptr(),
                    )),
                    ImageList_CreateEx: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ImageList_CreateEx)).as_ptr(),
                    )),
                    ImageList_Remove: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ImageList_Remove)).as_ptr(),
                    )),
                    ImageList_ReplaceIcon: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ImageList_ReplaceIcon)).as_ptr(),
                    )),
                    ImageList_Add: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ImageList_Add)).as_ptr(),
                    )),
                    ImageList_Destroy: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ImageList_Destroy)).as_ptr(),
                    )),
                    TabCtrl_GetItemCount: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TabCtrl_GetItemCount)).as_ptr(),
                    )),
                    TabCtrl_DeleteItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TabCtrl_DeleteItem)).as_ptr(),
                    )),
                    TabCtrl_InsertItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TabCtrl_InsertItem)).as_ptr(),
                    )),
                    TabCtrl_SetCurSel: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TabCtrl_SetCurSel)).as_ptr(),
                    )),
                    TabCtrl_GetCurSel: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TabCtrl_GetCurSel)).as_ptr(),
                    )),
                    TabCtrl_AdjustRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TabCtrl_AdjustRect)).as_ptr(),
                    )),
                    TreeView_InsertItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_InsertItem)).as_ptr(),
                    )),
                    TreeView_Expand: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_Expand)).as_ptr(),
                    )),
                    TreeView_GetSelection: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_GetSelection)).as_ptr(),
                    )),
                    TreeView_DeleteItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_DeleteItem)).as_ptr(),
                    )),
                    TreeView_DeleteAllItems: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_DeleteAllItems)).as_ptr(),
                    )),
                    TreeView_SelectItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_SelectItem)).as_ptr(),
                    )),
                    TreeView_GetItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_GetItem)).as_ptr(),
                    )),
                    TreeView_SetItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_SetItem)).as_ptr(),
                    )),
                    TreeView_HitTest: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_HitTest)).as_ptr(),
                    )),
                    TreeView_SetIndent: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_SetIndent)).as_ptr(),
                    )),
                    TreeView_GetChild: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_GetChild)).as_ptr(),
                    )),
                    TreeView_GetNextSibling: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_GetNextSibling)).as_ptr(),
                    )),
                    TreeView_GetRoot: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_GetRoot)).as_ptr(),
                    )),
                    TreeView_SetBkColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_SetBkColor)).as_ptr(),
                    )),
                    TreeView_SetTextColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TreeView_SetTextColor)).as_ptr(),
                    )),
                    ListView_SetBkColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetBkColor)).as_ptr(),
                    )),
                    ListView_SetTextBkColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetTextBkColor)).as_ptr(),
                    )),
                    ListView_SetTextColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetTextColor)).as_ptr(),
                    )),
                    ListView_SetGridColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetGridColor)).as_ptr(),
                    )),
                    ListView_SetSelColors: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ListView_SetSelColors)).as_ptr(),
                    )),
                    SWELL_ModalWindowStart: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_ModalWindowStart)).as_ptr(),
                    )),
                    SWELL_ModalWindowRun: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_ModalWindowRun)).as_ptr(),
                    )),
                    SWELL_ModalWindowEnd: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_ModalWindowEnd)).as_ptr(),
                    )),
                    SWELL_CloseWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_CloseWindow)).as_ptr(),
                    )),
                    CreatePopupMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreatePopupMenu)).as_ptr(),
                    )),
                    CreatePopupMenuEx: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreatePopupMenuEx)).as_ptr(),
                    )),
                    DestroyMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DestroyMenu)).as_ptr(),
                    )),
                    AddMenuItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(AddMenuItem)).as_ptr(),
                    )),
                    GetSubMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetSubMenu)).as_ptr(),
                    )),
                    GetMenuItemCount: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetMenuItemCount)).as_ptr(),
                    )),
                    GetMenuItemID: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetMenuItemID)).as_ptr(),
                    )),
                    SetMenuItemModifier: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetMenuItemModifier)).as_ptr(),
                    )),
                    SetMenuItemText: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetMenuItemText)).as_ptr(),
                    )),
                    EnableMenuItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(EnableMenuItem)).as_ptr(),
                    )),
                    DeleteMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DeleteMenu)).as_ptr(),
                    )),
                    CheckMenuItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CheckMenuItem)).as_ptr(),
                    )),
                    InsertMenuItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(InsertMenuItem)).as_ptr(),
                    )),
                    SWELL_InsertMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_InsertMenu)).as_ptr(),
                    )),
                    GetMenuItemInfo: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetMenuItemInfo)).as_ptr(),
                    )),
                    SetMenuItemInfo: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetMenuItemInfo)).as_ptr(),
                    )),
                    DrawMenuBar: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DrawMenuBar)).as_ptr(),
                    )),
                    SWELL_LoadMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_LoadMenu)).as_ptr(),
                    )),
                    TrackPopupMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(TrackPopupMenu)).as_ptr(),
                    )),
                    SWELL_SetMenuDestination: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetMenuDestination)).as_ptr(),
                    )),
                    SWELL_DuplicateMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_DuplicateMenu)).as_ptr(),
                    )),
                    SetMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetMenu)).as_ptr(),
                    )),
                    GetMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetMenu)).as_ptr(),
                    )),
                    SWELL_GetDefaultWindowMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetDefaultWindowMenu)).as_ptr(),
                    )),
                    SWELL_SetDefaultWindowMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetDefaultWindowMenu)).as_ptr(),
                    )),
                    SWELL_GetDefaultModalWindowMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetDefaultModalWindowMenu)).as_ptr(),
                    )),
                    SWELL_SetDefaultModalWindowMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetDefaultModalWindowMenu)).as_ptr(),
                    )),
                    SWELL_GetCurrentMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetCurrentMenu)).as_ptr(),
                    )),
                    SWELL_SetCurrentMenu: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetCurrentMenu)).as_ptr(),
                    )),
                    SWELL_DialogBox: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_DialogBox)).as_ptr(),
                    )),
                    SWELL_CreateDialog: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_CreateDialog)).as_ptr(),
                    )),
                    SWELL_RegisterCustomControlCreator: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_RegisterCustomControlCreator))
                            .as_ptr(),
                    )),
                    SWELL_UnregisterCustomControlCreator: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_UnregisterCustomControlCreator))
                            .as_ptr(),
                    )),
                    DefWindowProc: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DefWindowProc)).as_ptr(),
                    )),
                    EndDialog: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(EndDialog)).as_ptr(),
                    )),
                    SWELL_GetDefaultButtonID: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetDefaultButtonID)).as_ptr(),
                    )),
                    SendMessage: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SendMessage)).as_ptr(),
                    )),
                    SWELL_BroadcastMessage: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_BroadcastMessage)).as_ptr(),
                    )),
                    PostMessage: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(PostMessage)).as_ptr(),
                    )),
                    SWELL_MessageQueue_Flush: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MessageQueue_Flush)).as_ptr(),
                    )),
                    SWELL_MessageQueue_Clear: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MessageQueue_Clear)).as_ptr(),
                    )),
                    SWELL_KeyToASCII: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_KeyToASCII)).as_ptr(),
                    )),
                    GetAsyncKeyState: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetAsyncKeyState)).as_ptr(),
                    )),
                    GetCursorPos: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetCursorPos)).as_ptr(),
                    )),
                    GetMessagePos: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetMessagePos)).as_ptr(),
                    )),
                    SWELL_LoadCursor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_LoadCursor)).as_ptr(),
                    )),
                    SWELL_SetCursor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetCursor)).as_ptr(),
                    )),
                    SWELL_EnableRightClickEmulate: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_EnableRightClickEmulate)).as_ptr(),
                    )),
                    SWELL_GetCursor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetCursor)).as_ptr(),
                    )),
                    SWELL_GetLastSetCursor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetLastSetCursor)).as_ptr(),
                    )),
                    SWELL_IsCursorVisible: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_IsCursorVisible)).as_ptr(),
                    )),
                    SWELL_ShowCursor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_ShowCursor)).as_ptr(),
                    )),
                    SWELL_SetCursorPos: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetCursorPos)).as_ptr(),
                    )),
                    SWELL_GetViewPort: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetViewPort)).as_ptr(),
                    )),
                    OpenClipboard: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(OpenClipboard)).as_ptr(),
                    )),
                    CloseClipboard: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CloseClipboard)).as_ptr(),
                    )),
                    GetClipboardData: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetClipboardData)).as_ptr(),
                    )),
                    EmptyClipboard: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(EmptyClipboard)).as_ptr(),
                    )),
                    SetClipboardData: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetClipboardData)).as_ptr(),
                    )),
                    RegisterClipboardFormat: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(RegisterClipboardFormat)).as_ptr(),
                    )),
                    EnumClipboardFormats: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(EnumClipboardFormats)).as_ptr(),
                    )),
                    GlobalAlloc: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GlobalAlloc)).as_ptr(),
                    )),
                    GlobalLock: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GlobalLock)).as_ptr(),
                    )),
                    GlobalSize: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GlobalSize)).as_ptr(),
                    )),
                    GlobalUnlock: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GlobalUnlock)).as_ptr(),
                    )),
                    GlobalFree: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GlobalFree)).as_ptr(),
                    )),
                    CreateThread: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreateThread)).as_ptr(),
                    )),
                    CreateEvent: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreateEvent)).as_ptr(),
                    )),
                    CreateEventAsSocket: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreateEventAsSocket)).as_ptr(),
                    )),
                    GetCurrentThreadId: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetCurrentThreadId)).as_ptr(),
                    )),
                    WaitForSingleObject: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WaitForSingleObject)).as_ptr(),
                    )),
                    WaitForAnySocketObject: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(WaitForAnySocketObject)).as_ptr(),
                    )),
                    CloseHandle: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CloseHandle)).as_ptr(),
                    )),
                    SetThreadPriority: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetThreadPriority)).as_ptr(),
                    )),
                    SetEvent: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetEvent)).as_ptr(),
                    )),
                    ResetEvent: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ResetEvent)).as_ptr(),
                    )),
                    SWELL_CreateProcessFromPID: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_CreateProcessFromPID)).as_ptr(),
                    )),
                    SWELL_CreateProcess: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_CreateProcess)).as_ptr(),
                    )),
                    SWELL_GetProcessExitCode: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetProcessExitCode)).as_ptr(),
                    )),
                    LoadLibraryGlobals: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(LoadLibraryGlobals)).as_ptr(),
                    )),
                    LoadLibrary: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(LoadLibrary)).as_ptr(),
                    )),
                    GetProcAddress: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetProcAddress)).as_ptr(),
                    )),
                    FreeLibrary: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(FreeLibrary)).as_ptr(),
                    )),
                    SWELL_GetBundle: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetBundle)).as_ptr(),
                    )),
                    SWELL_CreateMemContext: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_CreateMemContext)).as_ptr(),
                    )),
                    SWELL_DeleteGfxContext: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_DeleteGfxContext)).as_ptr(),
                    )),
                    SWELL_GetCtxGC: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetCtxGC)).as_ptr(),
                    )),
                    SWELL_GetCtxFrameBuffer: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetCtxFrameBuffer)).as_ptr(),
                    )),
                    SWELL_PushClipRegion: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_PushClipRegion)).as_ptr(),
                    )),
                    SWELL_SetClipRegion: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetClipRegion)).as_ptr(),
                    )),
                    SWELL_PopClipRegion: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_PopClipRegion)).as_ptr(),
                    )),
                    CreateFontIndirect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreateFontIndirect)).as_ptr(),
                    )),
                    CreateFont: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreateFont)).as_ptr(),
                    )),
                    CreatePen: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreatePen)).as_ptr(),
                    )),
                    CreateSolidBrush: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreateSolidBrush)).as_ptr(),
                    )),
                    CreatePenAlpha: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreatePenAlpha)).as_ptr(),
                    )),
                    CreateSolidBrushAlpha: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreateSolidBrushAlpha)).as_ptr(),
                    )),
                    SelectObject: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SelectObject)).as_ptr(),
                    )),
                    GetStockObject: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetStockObject)).as_ptr(),
                    )),
                    DeleteObject: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DeleteObject)).as_ptr(),
                    )),
                    SWELL_FillRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_FillRect)).as_ptr(),
                    )),
                    Rectangle: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(Rectangle)).as_ptr(),
                    )),
                    Ellipse: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(Ellipse)).as_ptr(),
                    )),
                    SWELL_Polygon: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_Polygon)).as_ptr(),
                    )),
                    MoveToEx: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(MoveToEx)).as_ptr(),
                    )),
                    SWELL_LineTo: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_LineTo)).as_ptr(),
                    )),
                    SWELL_SetPixel: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetPixel)).as_ptr(),
                    )),
                    PolyBezierTo: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(PolyBezierTo)).as_ptr(),
                    )),
                    SWELL_DrawText: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_DrawText)).as_ptr(),
                    )),
                    SetTextColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetTextColor)).as_ptr(),
                    )),
                    GetTextColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetTextColor)).as_ptr(),
                    )),
                    SetBkColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetBkColor)).as_ptr(),
                    )),
                    SetBkMode: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetBkMode)).as_ptr(),
                    )),
                    GetGlyphIndicesW: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetGlyphIndicesW)).as_ptr(),
                    )),
                    RoundRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(RoundRect)).as_ptr(),
                    )),
                    PolyPolyline: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(PolyPolyline)).as_ptr(),
                    )),
                    GetTextMetrics: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetTextMetrics)).as_ptr(),
                    )),
                    GetTextFace: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetTextFace)).as_ptr(),
                    )),
                    GetObject: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetObject)).as_ptr(),
                    )),
                    CreateIconIndirect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreateIconIndirect)).as_ptr(),
                    )),
                    LoadNamedImage: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(LoadNamedImage)).as_ptr(),
                    )),
                    DrawImageInRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DrawImageInRect)).as_ptr(),
                    )),
                    BitBlt: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(BitBlt)).as_ptr(),
                    )),
                    StretchBlt: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(StretchBlt)).as_ptr(),
                    )),
                    StretchBltFromMem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(StretchBltFromMem)).as_ptr(),
                    )),
                    SWELL_GetScaling256: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetScaling256)).as_ptr(),
                    )),
                    SWELL_ExtendedAPI: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_ExtendedAPI)).as_ptr(),
                    )),
                    GetSysColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetSysColor)).as_ptr(),
                    )),
                    CreateBitmap: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(CreateBitmap)).as_ptr(),
                    )),
                    SetOpaque: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetOpaque)).as_ptr(),
                    )),
                    SetAllowNoMiddleManRendering: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SetAllowNoMiddleManRendering)).as_ptr(),
                    )),
                    BeginPaint: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(BeginPaint)).as_ptr(),
                    )),
                    EndPaint: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(EndPaint)).as_ptr(),
                    )),
                    GetDC: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetDC)).as_ptr(),
                    )),
                    GetWindowDC: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetWindowDC)).as_ptr(),
                    )),
                    ReleaseDC: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(ReleaseDC)).as_ptr(),
                    )),
                    SWELL_FillDialogBackground: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_FillDialogBackground)).as_ptr(),
                    )),
                    SWELL_CloneGDIObject: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_CloneGDIObject)).as_ptr(),
                    )),
                    GetSystemMetrics: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetSystemMetrics)).as_ptr(),
                    )),
                    DragQueryPoint: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DragQueryPoint)).as_ptr(),
                    )),
                    DragFinish: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DragFinish)).as_ptr(),
                    )),
                    DragQueryFile: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(DragQueryFile)).as_ptr(),
                    )),
                    SWELL_InitiateDragDrop: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_InitiateDragDrop)).as_ptr(),
                    )),
                    SWELL_InitiateDragDropOfFileList: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_InitiateDragDropOfFileList)).as_ptr(),
                    )),
                    SWELL_FinishDragDrop: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_FinishDragDrop)).as_ptr(),
                    )),
                    SWELL_DrawFocusRect: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_DrawFocusRect)).as_ptr(),
                    )),
                    SWELL_MakeSetCurParms: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MakeSetCurParms)).as_ptr(),
                    )),
                    SWELL_MakeButton: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MakeButton)).as_ptr(),
                    )),
                    SWELL_MakeEditField: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MakeEditField)).as_ptr(),
                    )),
                    SWELL_MakeLabel: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MakeLabel)).as_ptr(),
                    )),
                    SWELL_MakeControl: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MakeControl)).as_ptr(),
                    )),
                    SWELL_MakeCombo: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MakeCombo)).as_ptr(),
                    )),
                    SWELL_MakeGroupBox: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MakeGroupBox)).as_ptr(),
                    )),
                    SWELL_MakeCheckBox: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MakeCheckBox)).as_ptr(),
                    )),
                    SWELL_MakeListBox: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_MakeListBox)).as_ptr(),
                    )),
                    SWELL_Menu_AddMenuItem: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_Menu_AddMenuItem)).as_ptr(),
                    )),
                    SWELL_GenerateMenuFromList: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GenerateMenuFromList)).as_ptr(),
                    )),
                    SWELL_GenerateDialogFromList: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GenerateDialogFromList)).as_ptr(),
                    )),
                    _controlfp: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(_controlfp)).as_ptr(),
                    )),
                    SWELL_Internal_PostMessage_Init: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_Internal_PostMessage_Init)).as_ptr(),
                    )),
                    SWELL_LoadCursorFromFile: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_LoadCursorFromFile)).as_ptr(),
                    )),
                    SWELL_SetWindowWantRaiseAmt: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetWindowWantRaiseAmt)).as_ptr(),
                    )),
                    SWELL_GetWindowWantRaiseAmt: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetWindowWantRaiseAmt)).as_ptr(),
                    )),
                    SWELL_SetListViewFastClickMask: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetListViewFastClickMask)).as_ptr(),
                    )),
                    GetTempPath: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetTempPath)).as_ptr(),
                    )),
                    SWELL_initargs: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_initargs)).as_ptr(),
                    )),
                    SWELL_RunMessageLoop: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_RunMessageLoop)).as_ptr(),
                    )),
                    SWELL_CreateXBridgeWindow: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_CreateXBridgeWindow)).as_ptr(),
                    )),
                    SWELL_GenerateGUID: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GenerateGUID)).as_ptr(),
                    )),
                    EnumChildWindows: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(EnumChildWindows)).as_ptr(),
                    )),
                    SWELL_IsGroupBox: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_IsGroupBox)).as_ptr(),
                    )),
                    SWELL_IsButton: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_IsButton)).as_ptr(),
                    )),
                    SWELL_IsStaticText: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_IsStaticText)).as_ptr(),
                    )),
                    SWELL_GetDesiredControlSize: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_GetDesiredControlSize)).as_ptr(),
                    )),
                    AddFontResourceEx: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(AddFontResourceEx)).as_ptr(),
                    )),
                    SWELL_Register_Cursor_Resource: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_Register_Cursor_Resource)).as_ptr(),
                    )),
                    SWELL_ChooseColor: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_ChooseColor)).as_ptr(),
                    )),
                    SWELL_ChooseFont: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_ChooseFont)).as_ptr(),
                    )),
                    IsWindowEnabled: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(IsWindowEnabled)).as_ptr(),
                    )),
                    GetClassName: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(GetClassName)).as_ptr(),
                    )),
                    SWELL_SetClassName: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_SetClassName)).as_ptr(),
                    )),
                    SWELL_osx_is_dark_mode: std::mem::transmute(get_func(
                        c_str_macro::c_str!(stringify!(SWELL_osx_is_dark_mode)).as_ptr(),
                    )),
                }
            };
            if pointers.lstrcpyn.is_some() {
                loaded_count += 1;
            }
            if pointers.MulDiv.is_some() {
                loaded_count += 1;
            }
            if pointers.Sleep.is_some() {
                loaded_count += 1;
            }
            if pointers.GetTickCount.is_some() {
                loaded_count += 1;
            }
            if pointers.GetFileTime.is_some() {
                loaded_count += 1;
            }
            if pointers.WritePrivateProfileString.is_some() {
                loaded_count += 1;
            }
            if pointers.GetPrivateProfileString.is_some() {
                loaded_count += 1;
            }
            if pointers.GetPrivateProfileInt.is_some() {
                loaded_count += 1;
            }
            if pointers.GetPrivateProfileStruct.is_some() {
                loaded_count += 1;
            }
            if pointers.WritePrivateProfileStruct.is_some() {
                loaded_count += 1;
            }
            if pointers.WritePrivateProfileSection.is_some() {
                loaded_count += 1;
            }
            if pointers.GetPrivateProfileSection.is_some() {
                loaded_count += 1;
            }
            if pointers.GetModuleFileName.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_PtInRect.is_some() {
                loaded_count += 1;
            }
            if pointers.ShellExecute.is_some() {
                loaded_count += 1;
            }
            if pointers.MessageBox.is_some() {
                loaded_count += 1;
            }
            if pointers.BrowseForFiles.is_some() {
                loaded_count += 1;
            }
            if pointers.BrowseForSaveFile.is_some() {
                loaded_count += 1;
            }
            if pointers.BrowseForDirectory.is_some() {
                loaded_count += 1;
            }
            if pointers.BrowseFile_SetTemplate.is_some() {
                loaded_count += 1;
            }
            if pointers.GetDlgItem.is_some() {
                loaded_count += 1;
            }
            if pointers.ShowWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.DestroyWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetGestureInfo.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_HideApp.is_some() {
                loaded_count += 1;
            }
            if pointers.SetDlgItemText.is_some() {
                loaded_count += 1;
            }
            if pointers.SetDlgItemInt.is_some() {
                loaded_count += 1;
            }
            if pointers.GetDlgItemInt.is_some() {
                loaded_count += 1;
            }
            if pointers.GetDlgItemText.is_some() {
                loaded_count += 1;
            }
            if pointers.CheckDlgButton.is_some() {
                loaded_count += 1;
            }
            if pointers.IsDlgButtonChecked.is_some() {
                loaded_count += 1;
            }
            if pointers.EnableWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.SetFocus.is_some() {
                loaded_count += 1;
            }
            if pointers.GetFocus.is_some() {
                loaded_count += 1;
            }
            if pointers.SetForegroundWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.GetForegroundWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.SetCapture.is_some() {
                loaded_count += 1;
            }
            if pointers.GetCapture.is_some() {
                loaded_count += 1;
            }
            if pointers.ReleaseCapture.is_some() {
                loaded_count += 1;
            }
            if pointers.IsChild.is_some() {
                loaded_count += 1;
            }
            if pointers.GetParent.is_some() {
                loaded_count += 1;
            }
            if pointers.SetParent.is_some() {
                loaded_count += 1;
            }
            if pointers.GetWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.EnumWindows.is_some() {
                loaded_count += 1;
            }
            if pointers.FindWindowEx.is_some() {
                loaded_count += 1;
            }
            if pointers.ClientToScreen.is_some() {
                loaded_count += 1;
            }
            if pointers.ScreenToClient.is_some() {
                loaded_count += 1;
            }
            if pointers.GetWindowRect.is_some() {
                loaded_count += 1;
            }
            if pointers.GetWindowContentViewRect.is_some() {
                loaded_count += 1;
            }
            if pointers.GetClientRect.is_some() {
                loaded_count += 1;
            }
            if pointers.WindowFromPoint.is_some() {
                loaded_count += 1;
            }
            if pointers.WinOffsetRect.is_some() {
                loaded_count += 1;
            }
            if pointers.WinSetRect.is_some() {
                loaded_count += 1;
            }
            if pointers.WinUnionRect.is_some() {
                loaded_count += 1;
            }
            if pointers.WinIntersectRect.is_some() {
                loaded_count += 1;
            }
            if pointers.SetWindowPos.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetWindowLevel.is_some() {
                loaded_count += 1;
            }
            if pointers.InvalidateRect.is_some() {
                loaded_count += 1;
            }
            if pointers.UpdateWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.GetWindowLong.is_some() {
                loaded_count += 1;
            }
            if pointers.SetWindowLong.is_some() {
                loaded_count += 1;
            }
            if pointers.ScrollWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.EnumPropsEx.is_some() {
                loaded_count += 1;
            }
            if pointers.GetProp.is_some() {
                loaded_count += 1;
            }
            if pointers.SetProp.is_some() {
                loaded_count += 1;
            }
            if pointers.RemoveProp.is_some() {
                loaded_count += 1;
            }
            if pointers.IsWindowVisible.is_some() {
                loaded_count += 1;
            }
            if pointers.IsWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.SetTimer.is_some() {
                loaded_count += 1;
            }
            if pointers.KillTimer.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetExtendedListViewStyleEx.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_InsertColumn.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_DeleteColumn.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetColumn.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetColumnWidth.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_InsertItem.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetItemText.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetItem.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetNextItem.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetItem.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetItemState.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_DeleteItem.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_DeleteAllItems.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetSelectedCount.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetItemCount.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetSelectionMark.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetColumnWidth.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetItemState.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_RedrawItems.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetItemCount.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_EnsureVisible.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetSubItemRect.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetImageList.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_HitTest.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SubItemHitTest.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetItemText.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SortItems.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetItemRect.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_Scroll.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetTopIndex.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetCountPerPage.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetColumnOrderArray.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetColumnOrderArray.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_GetHeader.is_some() {
                loaded_count += 1;
            }
            if pointers.Header_GetItemCount.is_some() {
                loaded_count += 1;
            }
            if pointers.Header_GetItem.is_some() {
                loaded_count += 1;
            }
            if pointers.Header_SetItem.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetListViewHeaderHeight.is_some() {
                loaded_count += 1;
            }
            if pointers.ImageList_CreateEx.is_some() {
                loaded_count += 1;
            }
            if pointers.ImageList_Remove.is_some() {
                loaded_count += 1;
            }
            if pointers.ImageList_ReplaceIcon.is_some() {
                loaded_count += 1;
            }
            if pointers.ImageList_Add.is_some() {
                loaded_count += 1;
            }
            if pointers.ImageList_Destroy.is_some() {
                loaded_count += 1;
            }
            if pointers.TabCtrl_GetItemCount.is_some() {
                loaded_count += 1;
            }
            if pointers.TabCtrl_DeleteItem.is_some() {
                loaded_count += 1;
            }
            if pointers.TabCtrl_InsertItem.is_some() {
                loaded_count += 1;
            }
            if pointers.TabCtrl_SetCurSel.is_some() {
                loaded_count += 1;
            }
            if pointers.TabCtrl_GetCurSel.is_some() {
                loaded_count += 1;
            }
            if pointers.TabCtrl_AdjustRect.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_InsertItem.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_Expand.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_GetSelection.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_DeleteItem.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_DeleteAllItems.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_SelectItem.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_GetItem.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_SetItem.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_HitTest.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_SetIndent.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_GetChild.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_GetNextSibling.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_GetRoot.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_SetBkColor.is_some() {
                loaded_count += 1;
            }
            if pointers.TreeView_SetTextColor.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetBkColor.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetTextBkColor.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetTextColor.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetGridColor.is_some() {
                loaded_count += 1;
            }
            if pointers.ListView_SetSelColors.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_ModalWindowStart.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_ModalWindowRun.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_ModalWindowEnd.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_CloseWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.CreatePopupMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.CreatePopupMenuEx.is_some() {
                loaded_count += 1;
            }
            if pointers.DestroyMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.AddMenuItem.is_some() {
                loaded_count += 1;
            }
            if pointers.GetSubMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.GetMenuItemCount.is_some() {
                loaded_count += 1;
            }
            if pointers.GetMenuItemID.is_some() {
                loaded_count += 1;
            }
            if pointers.SetMenuItemModifier.is_some() {
                loaded_count += 1;
            }
            if pointers.SetMenuItemText.is_some() {
                loaded_count += 1;
            }
            if pointers.EnableMenuItem.is_some() {
                loaded_count += 1;
            }
            if pointers.DeleteMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.CheckMenuItem.is_some() {
                loaded_count += 1;
            }
            if pointers.InsertMenuItem.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_InsertMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.GetMenuItemInfo.is_some() {
                loaded_count += 1;
            }
            if pointers.SetMenuItemInfo.is_some() {
                loaded_count += 1;
            }
            if pointers.DrawMenuBar.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_LoadMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.TrackPopupMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetMenuDestination.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_DuplicateMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.SetMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.GetMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetDefaultWindowMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetDefaultWindowMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetDefaultModalWindowMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetDefaultModalWindowMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetCurrentMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetCurrentMenu.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_DialogBox.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_CreateDialog.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_RegisterCustomControlCreator.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_UnregisterCustomControlCreator.is_some() {
                loaded_count += 1;
            }
            if pointers.DefWindowProc.is_some() {
                loaded_count += 1;
            }
            if pointers.EndDialog.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetDefaultButtonID.is_some() {
                loaded_count += 1;
            }
            if pointers.SendMessage.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_BroadcastMessage.is_some() {
                loaded_count += 1;
            }
            if pointers.PostMessage.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MessageQueue_Flush.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MessageQueue_Clear.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_KeyToASCII.is_some() {
                loaded_count += 1;
            }
            if pointers.GetAsyncKeyState.is_some() {
                loaded_count += 1;
            }
            if pointers.GetCursorPos.is_some() {
                loaded_count += 1;
            }
            if pointers.GetMessagePos.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_LoadCursor.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetCursor.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_EnableRightClickEmulate.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetCursor.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetLastSetCursor.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_IsCursorVisible.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_ShowCursor.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetCursorPos.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetViewPort.is_some() {
                loaded_count += 1;
            }
            if pointers.OpenClipboard.is_some() {
                loaded_count += 1;
            }
            if pointers.CloseClipboard.is_some() {
                loaded_count += 1;
            }
            if pointers.GetClipboardData.is_some() {
                loaded_count += 1;
            }
            if pointers.EmptyClipboard.is_some() {
                loaded_count += 1;
            }
            if pointers.SetClipboardData.is_some() {
                loaded_count += 1;
            }
            if pointers.RegisterClipboardFormat.is_some() {
                loaded_count += 1;
            }
            if pointers.EnumClipboardFormats.is_some() {
                loaded_count += 1;
            }
            if pointers.GlobalAlloc.is_some() {
                loaded_count += 1;
            }
            if pointers.GlobalLock.is_some() {
                loaded_count += 1;
            }
            if pointers.GlobalSize.is_some() {
                loaded_count += 1;
            }
            if pointers.GlobalUnlock.is_some() {
                loaded_count += 1;
            }
            if pointers.GlobalFree.is_some() {
                loaded_count += 1;
            }
            if pointers.CreateThread.is_some() {
                loaded_count += 1;
            }
            if pointers.CreateEvent.is_some() {
                loaded_count += 1;
            }
            if pointers.CreateEventAsSocket.is_some() {
                loaded_count += 1;
            }
            if pointers.GetCurrentThreadId.is_some() {
                loaded_count += 1;
            }
            if pointers.WaitForSingleObject.is_some() {
                loaded_count += 1;
            }
            if pointers.WaitForAnySocketObject.is_some() {
                loaded_count += 1;
            }
            if pointers.CloseHandle.is_some() {
                loaded_count += 1;
            }
            if pointers.SetThreadPriority.is_some() {
                loaded_count += 1;
            }
            if pointers.SetEvent.is_some() {
                loaded_count += 1;
            }
            if pointers.ResetEvent.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_CreateProcessFromPID.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_CreateProcess.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetProcessExitCode.is_some() {
                loaded_count += 1;
            }
            if pointers.LoadLibraryGlobals.is_some() {
                loaded_count += 1;
            }
            if pointers.LoadLibrary.is_some() {
                loaded_count += 1;
            }
            if pointers.GetProcAddress.is_some() {
                loaded_count += 1;
            }
            if pointers.FreeLibrary.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetBundle.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_CreateMemContext.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_DeleteGfxContext.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetCtxGC.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetCtxFrameBuffer.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_PushClipRegion.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetClipRegion.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_PopClipRegion.is_some() {
                loaded_count += 1;
            }
            if pointers.CreateFontIndirect.is_some() {
                loaded_count += 1;
            }
            if pointers.CreateFont.is_some() {
                loaded_count += 1;
            }
            if pointers.CreatePen.is_some() {
                loaded_count += 1;
            }
            if pointers.CreateSolidBrush.is_some() {
                loaded_count += 1;
            }
            if pointers.CreatePenAlpha.is_some() {
                loaded_count += 1;
            }
            if pointers.CreateSolidBrushAlpha.is_some() {
                loaded_count += 1;
            }
            if pointers.SelectObject.is_some() {
                loaded_count += 1;
            }
            if pointers.GetStockObject.is_some() {
                loaded_count += 1;
            }
            if pointers.DeleteObject.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_FillRect.is_some() {
                loaded_count += 1;
            }
            if pointers.Rectangle.is_some() {
                loaded_count += 1;
            }
            if pointers.Ellipse.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_Polygon.is_some() {
                loaded_count += 1;
            }
            if pointers.MoveToEx.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_LineTo.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetPixel.is_some() {
                loaded_count += 1;
            }
            if pointers.PolyBezierTo.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_DrawText.is_some() {
                loaded_count += 1;
            }
            if pointers.SetTextColor.is_some() {
                loaded_count += 1;
            }
            if pointers.GetTextColor.is_some() {
                loaded_count += 1;
            }
            if pointers.SetBkColor.is_some() {
                loaded_count += 1;
            }
            if pointers.SetBkMode.is_some() {
                loaded_count += 1;
            }
            if pointers.GetGlyphIndicesW.is_some() {
                loaded_count += 1;
            }
            if pointers.RoundRect.is_some() {
                loaded_count += 1;
            }
            if pointers.PolyPolyline.is_some() {
                loaded_count += 1;
            }
            if pointers.GetTextMetrics.is_some() {
                loaded_count += 1;
            }
            if pointers.GetTextFace.is_some() {
                loaded_count += 1;
            }
            if pointers.GetObject.is_some() {
                loaded_count += 1;
            }
            if pointers.CreateIconIndirect.is_some() {
                loaded_count += 1;
            }
            if pointers.LoadNamedImage.is_some() {
                loaded_count += 1;
            }
            if pointers.DrawImageInRect.is_some() {
                loaded_count += 1;
            }
            if pointers.BitBlt.is_some() {
                loaded_count += 1;
            }
            if pointers.StretchBlt.is_some() {
                loaded_count += 1;
            }
            if pointers.StretchBltFromMem.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetScaling256.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_ExtendedAPI.is_some() {
                loaded_count += 1;
            }
            if pointers.GetSysColor.is_some() {
                loaded_count += 1;
            }
            if pointers.CreateBitmap.is_some() {
                loaded_count += 1;
            }
            if pointers.SetOpaque.is_some() {
                loaded_count += 1;
            }
            if pointers.SetAllowNoMiddleManRendering.is_some() {
                loaded_count += 1;
            }
            if pointers.BeginPaint.is_some() {
                loaded_count += 1;
            }
            if pointers.EndPaint.is_some() {
                loaded_count += 1;
            }
            if pointers.GetDC.is_some() {
                loaded_count += 1;
            }
            if pointers.GetWindowDC.is_some() {
                loaded_count += 1;
            }
            if pointers.ReleaseDC.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_FillDialogBackground.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_CloneGDIObject.is_some() {
                loaded_count += 1;
            }
            if pointers.GetSystemMetrics.is_some() {
                loaded_count += 1;
            }
            if pointers.DragQueryPoint.is_some() {
                loaded_count += 1;
            }
            if pointers.DragFinish.is_some() {
                loaded_count += 1;
            }
            if pointers.DragQueryFile.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_InitiateDragDrop.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_InitiateDragDropOfFileList.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_FinishDragDrop.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_DrawFocusRect.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MakeSetCurParms.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MakeButton.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MakeEditField.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MakeLabel.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MakeControl.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MakeCombo.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MakeGroupBox.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MakeCheckBox.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_MakeListBox.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_Menu_AddMenuItem.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GenerateMenuFromList.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GenerateDialogFromList.is_some() {
                loaded_count += 1;
            }
            if pointers._controlfp.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_Internal_PostMessage_Init.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_LoadCursorFromFile.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetWindowWantRaiseAmt.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetWindowWantRaiseAmt.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetListViewFastClickMask.is_some() {
                loaded_count += 1;
            }
            if pointers.GetTempPath.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_initargs.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_RunMessageLoop.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_CreateXBridgeWindow.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GenerateGUID.is_some() {
                loaded_count += 1;
            }
            if pointers.EnumChildWindows.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_IsGroupBox.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_IsButton.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_IsStaticText.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_GetDesiredControlSize.is_some() {
                loaded_count += 1;
            }
            if pointers.AddFontResourceEx.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_Register_Cursor_Resource.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_ChooseColor.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_ChooseFont.is_some() {
                loaded_count += 1;
            }
            if pointers.IsWindowEnabled.is_some() {
                loaded_count += 1;
            }
            if pointers.GetClassName.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_SetClassName.is_some() {
                loaded_count += 1;
            }
            if pointers.SWELL_osx_is_dark_mode.is_some() {
                loaded_count += 1;
            }
            pointers.loaded_count = loaded_count;
            Swell {
                pointers,
                plugin_context: Some(plugin_context),
            }
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn lstrcpyn(
        &self,
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        l: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char {
        match self.pointers.lstrcpyn {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(lstrcpyn)
            )),
            Some(f) => f(dest, src, l),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn MulDiv(
        &self,
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.MulDiv {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(MulDiv)
            )),
            Some(f) => f(arg1, arg2, arg3),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn Sleep(&self, ms: ::std::os::raw::c_int) {
        match self.pointers.Sleep {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(Sleep)
            )),
            Some(f) => f(ms),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetTickCount(&self) -> root::DWORD {
        match self.pointers.GetTickCount {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetTickCount)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetFileTime(
        &self,
        filedes: ::std::os::raw::c_int,
        lpCreationTime: *mut root::FILETIME,
        lpLastAccessTime: *mut root::FILETIME,
        lpLastWriteTime: *mut root::FILETIME,
    ) -> root::BOOL {
        match self.pointers.GetFileTime {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetFileTime)
            )),
            Some(f) => f(filedes, lpCreationTime, lpLastAccessTime, lpLastWriteTime),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WritePrivateProfileString(
        &self,
        appname: *const ::std::os::raw::c_char,
        keyname: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        fn_: *const ::std::os::raw::c_char,
    ) -> root::BOOL {
        match self.pointers.WritePrivateProfileString {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WritePrivateProfileString)
            )),
            Some(f) => f(appname, keyname, val, fn_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetPrivateProfileString(
        &self,
        appname: *const ::std::os::raw::c_char,
        keyname: *const ::std::os::raw::c_char,
        def: *const ::std::os::raw::c_char,
        ret: *mut ::std::os::raw::c_char,
        retsize: ::std::os::raw::c_int,
        fn_: *const ::std::os::raw::c_char,
    ) -> root::DWORD {
        match self.pointers.GetPrivateProfileString {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetPrivateProfileString)
            )),
            Some(f) => f(appname, keyname, def, ret, retsize, fn_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetPrivateProfileInt(
        &self,
        appname: *const ::std::os::raw::c_char,
        keyname: *const ::std::os::raw::c_char,
        def: ::std::os::raw::c_int,
        fn_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        match self.pointers.GetPrivateProfileInt {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetPrivateProfileInt)
            )),
            Some(f) => f(appname, keyname, def, fn_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetPrivateProfileStruct(
        &self,
        appname: *const ::std::os::raw::c_char,
        keyname: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_void,
        bufsz: ::std::os::raw::c_int,
        fn_: *const ::std::os::raw::c_char,
    ) -> root::BOOL {
        match self.pointers.GetPrivateProfileStruct {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetPrivateProfileStruct)
            )),
            Some(f) => f(appname, keyname, buf, bufsz, fn_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WritePrivateProfileStruct(
        &self,
        appname: *const ::std::os::raw::c_char,
        keyname: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_void,
        bufsz: ::std::os::raw::c_int,
        fn_: *const ::std::os::raw::c_char,
    ) -> root::BOOL {
        match self.pointers.WritePrivateProfileStruct {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WritePrivateProfileStruct)
            )),
            Some(f) => f(appname, keyname, buf, bufsz, fn_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WritePrivateProfileSection(
        &self,
        appname: *const ::std::os::raw::c_char,
        strings: *const ::std::os::raw::c_char,
        fn_: *const ::std::os::raw::c_char,
    ) -> root::BOOL {
        match self.pointers.WritePrivateProfileSection {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WritePrivateProfileSection)
            )),
            Some(f) => f(appname, strings, fn_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetPrivateProfileSection(
        &self,
        appname: *const ::std::os::raw::c_char,
        strout: *mut ::std::os::raw::c_char,
        strout_len: root::DWORD,
        fn_: *const ::std::os::raw::c_char,
    ) -> root::DWORD {
        match self.pointers.GetPrivateProfileSection {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetPrivateProfileSection)
            )),
            Some(f) => f(appname, strout, strout_len, fn_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetModuleFileName(
        &self,
        hInst: root::HINSTANCE,
        fn_: *mut ::std::os::raw::c_char,
        nSize: root::DWORD,
    ) -> root::DWORD {
        match self.pointers.GetModuleFileName {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetModuleFileName)
            )),
            Some(f) => f(hInst, fn_, nSize),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_PtInRect(&self, r: *const root::RECT, p: root::POINT) -> root::BOOL {
        match self.pointers.SWELL_PtInRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_PtInRect)
            )),
            Some(f) => f(r, p),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ShellExecute(
        &self,
        hwndDlg: root::HWND,
        action: *const ::std::os::raw::c_char,
        content1: *const ::std::os::raw::c_char,
        content2: *const ::std::os::raw::c_char,
        content3: *const ::std::os::raw::c_char,
        blah: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.ShellExecute {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ShellExecute)
            )),
            Some(f) => f(hwndDlg, action, content1, content2, content3, blah),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn MessageBox(
        &self,
        hwndParent: root::HWND,
        text: *const ::std::os::raw::c_char,
        caption: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.MessageBox {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(MessageBox)
            )),
            Some(f) => f(hwndParent, text, caption, type_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn BrowseForFiles(
        &self,
        text: *const ::std::os::raw::c_char,
        initialdir: *const ::std::os::raw::c_char,
        initialfile: *const ::std::os::raw::c_char,
        allowmul: bool,
        extlist: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        match self.pointers.BrowseForFiles {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(BrowseForFiles)
            )),
            Some(f) => f(text, initialdir, initialfile, allowmul, extlist),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn BrowseForSaveFile(
        &self,
        text: *const ::std::os::raw::c_char,
        initialdir: *const ::std::os::raw::c_char,
        initialfile: *const ::std::os::raw::c_char,
        extlist: *const ::std::os::raw::c_char,
        fn_: *mut ::std::os::raw::c_char,
        fnsize: ::std::os::raw::c_int,
    ) -> bool {
        match self.pointers.BrowseForSaveFile {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(BrowseForSaveFile)
            )),
            Some(f) => f(text, initialdir, initialfile, extlist, fn_, fnsize),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn BrowseForDirectory(
        &self,
        text: *const ::std::os::raw::c_char,
        initialdir: *const ::std::os::raw::c_char,
        fn_: *mut ::std::os::raw::c_char,
        fnsize: ::std::os::raw::c_int,
    ) -> bool {
        match self.pointers.BrowseForDirectory {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(BrowseForDirectory)
            )),
            Some(f) => f(text, initialdir, fn_, fnsize),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn BrowseFile_SetTemplate(
        &self,
        dlgid: *const ::std::os::raw::c_char,
        dlgProc: root::DLGPROC,
        reshead: *mut root::SWELL_DialogResourceIndex,
    ) {
        match self.pointers.BrowseFile_SetTemplate {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(BrowseFile_SetTemplate)
            )),
            Some(f) => f(dlgid, dlgProc, reshead),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetDlgItem(&self, arg1: root::HWND, arg2: ::std::os::raw::c_int) -> root::HWND {
        match self.pointers.GetDlgItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetDlgItem)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ShowWindow(&self, arg1: root::HWND, arg2: ::std::os::raw::c_int) {
        match self.pointers.ShowWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ShowWindow)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DestroyWindow(&self, hwnd: root::HWND) {
        match self.pointers.DestroyWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DestroyWindow)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetGestureInfo(
        &self,
        lParam: root::LPARAM,
        gi: *mut root::GESTUREINFO,
    ) -> root::BOOL {
        match self.pointers.SWELL_GetGestureInfo {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetGestureInfo)
            )),
            Some(f) => f(lParam, gi),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_HideApp(&self) {
        match self.pointers.SWELL_HideApp {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_HideApp)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetDlgItemText(
        &self,
        arg1: root::HWND,
        idx: ::std::os::raw::c_int,
        text: *const ::std::os::raw::c_char,
    ) -> root::BOOL {
        match self.pointers.SetDlgItemText {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetDlgItemText)
            )),
            Some(f) => f(arg1, idx, text),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetDlgItemInt(
        &self,
        arg1: root::HWND,
        idx: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
        issigned: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.SetDlgItemInt {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetDlgItemInt)
            )),
            Some(f) => f(arg1, idx, val, issigned),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetDlgItemInt(
        &self,
        arg1: root::HWND,
        idx: ::std::os::raw::c_int,
        translated: *mut root::BOOL,
        issigned: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.GetDlgItemInt {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetDlgItemInt)
            )),
            Some(f) => f(arg1, idx, translated, issigned),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetDlgItemText(
        &self,
        arg1: root::HWND,
        idx: ::std::os::raw::c_int,
        text: *mut ::std::os::raw::c_char,
        textlen: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.GetDlgItemText {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetDlgItemText)
            )),
            Some(f) => f(arg1, idx, text, textlen),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CheckDlgButton(
        &self,
        hwnd: root::HWND,
        idx: ::std::os::raw::c_int,
        check: ::std::os::raw::c_int,
    ) {
        match self.pointers.CheckDlgButton {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CheckDlgButton)
            )),
            Some(f) => f(hwnd, idx, check),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsDlgButtonChecked(
        &self,
        hwnd: root::HWND,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.IsDlgButtonChecked {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(IsDlgButtonChecked)
            )),
            Some(f) => f(hwnd, idx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnableWindow(&self, hwnd: root::HWND, enable: ::std::os::raw::c_int) {
        match self.pointers.EnableWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(EnableWindow)
            )),
            Some(f) => f(hwnd, enable),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetFocus(&self, hwnd: root::HWND) {
        match self.pointers.SetFocus {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetFocus)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetFocus(&self) -> root::HWND {
        match self.pointers.GetFocus {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetFocus)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetForegroundWindow(&self, hwnd: root::HWND) {
        match self.pointers.SetForegroundWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetForegroundWindow)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetForegroundWindow(&self) -> root::HWND {
        match self.pointers.GetForegroundWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetForegroundWindow)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetCapture(&self, hwnd: root::HWND) -> root::HWND {
        match self.pointers.SetCapture {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetCapture)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetCapture(&self) -> root::HWND {
        match self.pointers.GetCapture {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetCapture)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn ReleaseCapture(&self) {
        match self.pointers.ReleaseCapture {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ReleaseCapture)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsChild(
        &self,
        hwndParent: root::HWND,
        hwndChild: root::HWND,
    ) -> ::std::os::raw::c_int {
        match self.pointers.IsChild {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(IsChild)
            )),
            Some(f) => f(hwndParent, hwndChild),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetParent(&self, hwnd: root::HWND) -> root::HWND {
        match self.pointers.GetParent {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetParent)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetParent(&self, hwnd: root::HWND, newPar: root::HWND) -> root::HWND {
        match self.pointers.SetParent {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetParent)
            )),
            Some(f) => f(hwnd, newPar),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetWindow(&self, hwnd: root::HWND, what: ::std::os::raw::c_int) -> root::HWND {
        match self.pointers.GetWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetWindow)
            )),
            Some(f) => f(hwnd, what),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnumWindows(
        &self,
        proc_: ::std::option::Option<
            unsafe extern "C" fn(arg1: root::HWND, arg2: root::LPARAM) -> root::BOOL,
        >,
        lp: root::LPARAM,
    ) -> root::BOOL {
        match self.pointers.EnumWindows {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(EnumWindows)
            )),
            Some(f) => f(proc_, lp),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn FindWindowEx(
        &self,
        par: root::HWND,
        lastw: root::HWND,
        classname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> root::HWND {
        match self.pointers.FindWindowEx {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(FindWindowEx)
            )),
            Some(f) => f(par, lastw, classname, title),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ClientToScreen(&self, hwnd: root::HWND, p: *mut root::POINT) {
        match self.pointers.ClientToScreen {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ClientToScreen)
            )),
            Some(f) => f(hwnd, p),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ScreenToClient(&self, hwnd: root::HWND, p: *mut root::POINT) {
        match self.pointers.ScreenToClient {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ScreenToClient)
            )),
            Some(f) => f(hwnd, p),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetWindowRect(&self, hwnd: root::HWND, r: *mut root::RECT) -> bool {
        match self.pointers.GetWindowRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetWindowRect)
            )),
            Some(f) => f(hwnd, r),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetWindowContentViewRect(&self, hwnd: root::HWND, r: *mut root::RECT) {
        match self.pointers.GetWindowContentViewRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetWindowContentViewRect)
            )),
            Some(f) => f(hwnd, r),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetClientRect(&self, hwnd: root::HWND, r: *mut root::RECT) {
        match self.pointers.GetClientRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetClientRect)
            )),
            Some(f) => f(hwnd, r),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WindowFromPoint(&self, p: root::POINT) -> root::HWND {
        match self.pointers.WindowFromPoint {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WindowFromPoint)
            )),
            Some(f) => f(p),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WinOffsetRect(
        &self,
        lprc: root::LPRECT,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.WinOffsetRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WinOffsetRect)
            )),
            Some(f) => f(lprc, dx, dy),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WinSetRect(
        &self,
        lprc: root::LPRECT,
        xLeft: ::std::os::raw::c_int,
        yTop: ::std::os::raw::c_int,
        xRight: ::std::os::raw::c_int,
        yBottom: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.WinSetRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WinSetRect)
            )),
            Some(f) => f(lprc, xLeft, yTop, xRight, yBottom),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WinUnionRect(
        &self,
        out: *mut root::RECT,
        in1: *const root::RECT,
        in2: *const root::RECT,
    ) {
        match self.pointers.WinUnionRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WinUnionRect)
            )),
            Some(f) => f(out, in1, in2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WinIntersectRect(
        &self,
        out: *mut root::RECT,
        in1: *const root::RECT,
        in2: *const root::RECT,
    ) -> ::std::os::raw::c_int {
        match self.pointers.WinIntersectRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WinIntersectRect)
            )),
            Some(f) => f(out, in1, in2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetWindowPos(
        &self,
        hwnd: root::HWND,
        unused: root::HWND,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) {
        match self.pointers.SetWindowPos {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetWindowPos)
            )),
            Some(f) => f(hwnd, unused, x, y, cx, cy, flags),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetWindowLevel(
        &self,
        hwnd: root::HWND,
        newlevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_SetWindowLevel {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetWindowLevel)
            )),
            Some(f) => f(hwnd, newlevel),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn InvalidateRect(
        &self,
        hwnd: root::HWND,
        r: *const root::RECT,
        eraseBk: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.InvalidateRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(InvalidateRect)
            )),
            Some(f) => f(hwnd, r, eraseBk),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn UpdateWindow(&self, hwnd: root::HWND) {
        match self.pointers.UpdateWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(UpdateWindow)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetWindowLong(
        &self,
        hwnd: root::HWND,
        idx: ::std::os::raw::c_int,
    ) -> root::LONG_PTR {
        match self.pointers.GetWindowLong {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetWindowLong)
            )),
            Some(f) => f(hwnd, idx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetWindowLong(
        &self,
        hwnd: root::HWND,
        idx: ::std::os::raw::c_int,
        val: root::LONG_PTR,
    ) -> root::LONG_PTR {
        match self.pointers.SetWindowLong {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetWindowLong)
            )),
            Some(f) => f(hwnd, idx, val),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ScrollWindow(
        &self,
        hwnd: root::HWND,
        xamt: ::std::os::raw::c_int,
        yamt: ::std::os::raw::c_int,
        lpRect: *const root::RECT,
        lpClipRect: *const root::RECT,
    ) -> root::BOOL {
        match self.pointers.ScrollWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ScrollWindow)
            )),
            Some(f) => f(hwnd, xamt, yamt, lpRect, lpClipRect),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnumPropsEx(
        &self,
        arg1: root::HWND,
        arg2: root::PROPENUMPROCEX,
        arg3: root::LPARAM,
    ) -> ::std::os::raw::c_int {
        match self.pointers.EnumPropsEx {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(EnumPropsEx)
            )),
            Some(f) => f(arg1, arg2, arg3),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetProp(
        &self,
        arg1: root::HWND,
        arg2: *const ::std::os::raw::c_char,
    ) -> root::HANDLE {
        match self.pointers.GetProp {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetProp)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetProp(
        &self,
        arg1: root::HWND,
        arg2: *const ::std::os::raw::c_char,
        arg3: root::HANDLE,
    ) -> root::BOOL {
        match self.pointers.SetProp {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetProp)
            )),
            Some(f) => f(arg1, arg2, arg3),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn RemoveProp(
        &self,
        arg1: root::HWND,
        arg2: *const ::std::os::raw::c_char,
    ) -> root::HANDLE {
        match self.pointers.RemoveProp {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(RemoveProp)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsWindowVisible(&self, hwnd: root::HWND) -> bool {
        match self.pointers.IsWindowVisible {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(IsWindowVisible)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsWindow(&self, hwnd: root::HWND) -> bool {
        match self.pointers.IsWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(IsWindow)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetTimer(
        &self,
        hwnd: root::HWND,
        timerid: root::UINT_PTR,
        rate: root::UINT,
        tProc: root::TIMERPROC,
    ) -> root::UINT_PTR {
        match self.pointers.SetTimer {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetTimer)
            )),
            Some(f) => f(hwnd, timerid, rate, tProc),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn KillTimer(&self, hwnd: root::HWND, timerid: root::UINT_PTR) -> root::BOOL {
        match self.pointers.KillTimer {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(KillTimer)
            )),
            Some(f) => f(hwnd, timerid),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetExtendedListViewStyleEx(
        &self,
        h: root::HWND,
        mask: ::std::os::raw::c_int,
        style: ::std::os::raw::c_int,
    ) {
        match self.pointers.ListView_SetExtendedListViewStyleEx {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetExtendedListViewStyleEx)
            )),
            Some(f) => f(h, mask, style),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_InsertColumn(
        &self,
        h: root::HWND,
        pos: ::std::os::raw::c_int,
        lvc: *const root::LVCOLUMN,
    ) {
        match self.pointers.ListView_InsertColumn {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_InsertColumn)
            )),
            Some(f) => f(h, pos, lvc),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_DeleteColumn(&self, h: root::HWND, pos: ::std::os::raw::c_int) -> bool {
        match self.pointers.ListView_DeleteColumn {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_DeleteColumn)
            )),
            Some(f) => f(h, pos),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetColumn(
        &self,
        h: root::HWND,
        pos: ::std::os::raw::c_int,
        lvc: *const root::LVCOLUMN,
    ) {
        match self.pointers.ListView_SetColumn {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetColumn)
            )),
            Some(f) => f(h, pos, lvc),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetColumnWidth(
        &self,
        h: root::HWND,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.ListView_GetColumnWidth {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetColumnWidth)
            )),
            Some(f) => f(h, pos),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_InsertItem(
        &self,
        h: root::HWND,
        item: *const root::LVITEM,
    ) -> ::std::os::raw::c_int {
        match self.pointers.ListView_InsertItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_InsertItem)
            )),
            Some(f) => f(h, item),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetItemText(
        &self,
        h: root::HWND,
        ipos: ::std::os::raw::c_int,
        cpos: ::std::os::raw::c_int,
        txt: *const ::std::os::raw::c_char,
    ) {
        match self.pointers.ListView_SetItemText {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetItemText)
            )),
            Some(f) => f(h, ipos, cpos, txt),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetItem(&self, h: root::HWND, item: *mut root::LVITEM) -> bool {
        match self.pointers.ListView_SetItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetItem)
            )),
            Some(f) => f(h, item),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetNextItem(
        &self,
        h: root::HWND,
        istart: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.ListView_GetNextItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetNextItem)
            )),
            Some(f) => f(h, istart, flags),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetItem(&self, h: root::HWND, item: *mut root::LVITEM) -> bool {
        match self.pointers.ListView_GetItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetItem)
            )),
            Some(f) => f(h, item),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetItemState(
        &self,
        h: root::HWND,
        ipos: ::std::os::raw::c_int,
        mask: root::UINT,
    ) -> ::std::os::raw::c_int {
        match self.pointers.ListView_GetItemState {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetItemState)
            )),
            Some(f) => f(h, ipos, mask),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_DeleteItem(&self, h: root::HWND, ipos: ::std::os::raw::c_int) {
        match self.pointers.ListView_DeleteItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_DeleteItem)
            )),
            Some(f) => f(h, ipos),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_DeleteAllItems(&self, h: root::HWND) {
        match self.pointers.ListView_DeleteAllItems {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_DeleteAllItems)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetSelectedCount(&self, h: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.ListView_GetSelectedCount {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetSelectedCount)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetItemCount(&self, h: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.ListView_GetItemCount {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetItemCount)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetSelectionMark(&self, h: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.ListView_GetSelectionMark {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetSelectionMark)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetColumnWidth(
        &self,
        h: root::HWND,
        colpos: ::std::os::raw::c_int,
        wid: ::std::os::raw::c_int,
    ) {
        match self.pointers.ListView_SetColumnWidth {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetColumnWidth)
            )),
            Some(f) => f(h, colpos, wid),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetItemState(
        &self,
        h: root::HWND,
        item: ::std::os::raw::c_int,
        state: root::UINT,
        statemask: root::UINT,
    ) -> bool {
        match self.pointers.ListView_SetItemState {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetItemState)
            )),
            Some(f) => f(h, item, state, statemask),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_RedrawItems(
        &self,
        h: root::HWND,
        startitem: ::std::os::raw::c_int,
        enditem: ::std::os::raw::c_int,
    ) {
        match self.pointers.ListView_RedrawItems {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_RedrawItems)
            )),
            Some(f) => f(h, startitem, enditem),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetItemCount(&self, h: root::HWND, cnt: ::std::os::raw::c_int) {
        match self.pointers.ListView_SetItemCount {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetItemCount)
            )),
            Some(f) => f(h, cnt),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_EnsureVisible(
        &self,
        h: root::HWND,
        i: ::std::os::raw::c_int,
        pok: root::BOOL,
    ) {
        match self.pointers.ListView_EnsureVisible {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_EnsureVisible)
            )),
            Some(f) => f(h, i, pok),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetSubItemRect(
        &self,
        h: root::HWND,
        item: ::std::os::raw::c_int,
        subitem: ::std::os::raw::c_int,
        code: ::std::os::raw::c_int,
        r: *mut root::RECT,
    ) -> bool {
        match self.pointers.ListView_GetSubItemRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetSubItemRect)
            )),
            Some(f) => f(h, item, subitem, code, r),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetImageList(
        &self,
        h: root::HWND,
        imagelist: root::HIMAGELIST,
        which: ::std::os::raw::c_int,
    ) {
        match self.pointers.ListView_SetImageList {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetImageList)
            )),
            Some(f) => f(h, imagelist, which),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_HitTest(
        &self,
        h: root::HWND,
        pinf: *mut root::LVHITTESTINFO,
    ) -> ::std::os::raw::c_int {
        match self.pointers.ListView_HitTest {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_HitTest)
            )),
            Some(f) => f(h, pinf),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SubItemHitTest(
        &self,
        h: root::HWND,
        pinf: *mut root::LVHITTESTINFO,
    ) -> ::std::os::raw::c_int {
        match self.pointers.ListView_SubItemHitTest {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SubItemHitTest)
            )),
            Some(f) => f(h, pinf),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetItemText(
        &self,
        hwnd: root::HWND,
        item: ::std::os::raw::c_int,
        subitem: ::std::os::raw::c_int,
        text: *mut ::std::os::raw::c_char,
        textmax: ::std::os::raw::c_int,
    ) {
        match self.pointers.ListView_GetItemText {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetItemText)
            )),
            Some(f) => f(hwnd, item, subitem, text, textmax),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SortItems(
        &self,
        hwnd: root::HWND,
        compf: root::PFNLVCOMPARE,
        parm: root::LPARAM,
    ) {
        match self.pointers.ListView_SortItems {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SortItems)
            )),
            Some(f) => f(hwnd, compf, parm),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetItemRect(
        &self,
        h: root::HWND,
        item: ::std::os::raw::c_int,
        r: *mut root::RECT,
        code: ::std::os::raw::c_int,
    ) -> bool {
        match self.pointers.ListView_GetItemRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetItemRect)
            )),
            Some(f) => f(h, item, r, code),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_Scroll(
        &self,
        h: root::HWND,
        xscroll: ::std::os::raw::c_int,
        yscroll: ::std::os::raw::c_int,
    ) -> bool {
        match self.pointers.ListView_Scroll {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_Scroll)
            )),
            Some(f) => f(h, xscroll, yscroll),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetTopIndex(&self, h: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.ListView_GetTopIndex {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetTopIndex)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetCountPerPage(&self, h: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.ListView_GetCountPerPage {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetCountPerPage)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetColumnOrderArray(
        &self,
        h: root::HWND,
        cnt: ::std::os::raw::c_int,
        arr: *mut ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.ListView_SetColumnOrderArray {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetColumnOrderArray)
            )),
            Some(f) => f(h, cnt, arr),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetColumnOrderArray(
        &self,
        h: root::HWND,
        cnt: ::std::os::raw::c_int,
        arr: *mut ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.ListView_GetColumnOrderArray {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetColumnOrderArray)
            )),
            Some(f) => f(h, cnt, arr),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_GetHeader(&self, h: root::HWND) -> root::HWND {
        match self.pointers.ListView_GetHeader {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_GetHeader)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn Header_GetItemCount(&self, h: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.Header_GetItemCount {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(Header_GetItemCount)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn Header_GetItem(
        &self,
        h: root::HWND,
        col: ::std::os::raw::c_int,
        hi: *mut root::HDITEM,
    ) -> root::BOOL {
        match self.pointers.Header_GetItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(Header_GetItem)
            )),
            Some(f) => f(h, col, hi),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn Header_SetItem(
        &self,
        h: root::HWND,
        col: ::std::os::raw::c_int,
        hi: *mut root::HDITEM,
    ) -> root::BOOL {
        match self.pointers.Header_SetItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(Header_SetItem)
            )),
            Some(f) => f(h, col, hi),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetListViewHeaderHeight(&self, h: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_GetListViewHeaderHeight {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetListViewHeaderHeight)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn ImageList_CreateEx(&self) -> root::HIMAGELIST {
        match self.pointers.ImageList_CreateEx {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ImageList_CreateEx)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ImageList_Remove(
        &self,
        list: root::HIMAGELIST,
        idx: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.ImageList_Remove {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ImageList_Remove)
            )),
            Some(f) => f(list, idx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ImageList_ReplaceIcon(
        &self,
        list: root::HIMAGELIST,
        offset: ::std::os::raw::c_int,
        image: root::HICON,
    ) -> ::std::os::raw::c_int {
        match self.pointers.ImageList_ReplaceIcon {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ImageList_ReplaceIcon)
            )),
            Some(f) => f(list, offset, image),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ImageList_Add(
        &self,
        list: root::HIMAGELIST,
        image: root::HBITMAP,
        mask: root::HBITMAP,
    ) -> ::std::os::raw::c_int {
        match self.pointers.ImageList_Add {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ImageList_Add)
            )),
            Some(f) => f(list, image, mask),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ImageList_Destroy(&self, arg1: root::HIMAGELIST) {
        match self.pointers.ImageList_Destroy {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ImageList_Destroy)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TabCtrl_GetItemCount(&self, hwnd: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.TabCtrl_GetItemCount {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TabCtrl_GetItemCount)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TabCtrl_DeleteItem(
        &self,
        hwnd: root::HWND,
        idx: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.TabCtrl_DeleteItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TabCtrl_DeleteItem)
            )),
            Some(f) => f(hwnd, idx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TabCtrl_InsertItem(
        &self,
        hwnd: root::HWND,
        idx: ::std::os::raw::c_int,
        item: *mut root::TCITEM,
    ) -> ::std::os::raw::c_int {
        match self.pointers.TabCtrl_InsertItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TabCtrl_InsertItem)
            )),
            Some(f) => f(hwnd, idx, item),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TabCtrl_SetCurSel(
        &self,
        hwnd: root::HWND,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.TabCtrl_SetCurSel {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TabCtrl_SetCurSel)
            )),
            Some(f) => f(hwnd, idx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TabCtrl_GetCurSel(&self, hwnd: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.TabCtrl_GetCurSel {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TabCtrl_GetCurSel)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TabCtrl_AdjustRect(
        &self,
        hwnd: root::HWND,
        fLarger: root::BOOL,
        r: *mut root::RECT,
    ) -> root::BOOL {
        match self.pointers.TabCtrl_AdjustRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TabCtrl_AdjustRect)
            )),
            Some(f) => f(hwnd, fLarger, r),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_InsertItem(
        &self,
        hwnd: root::HWND,
        ins: *mut root::TV_INSERTSTRUCT,
    ) -> root::HTREEITEM {
        match self.pointers.TreeView_InsertItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_InsertItem)
            )),
            Some(f) => f(hwnd, ins),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_Expand(
        &self,
        hwnd: root::HWND,
        item: root::HTREEITEM,
        flag: root::UINT,
    ) -> root::BOOL {
        match self.pointers.TreeView_Expand {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_Expand)
            )),
            Some(f) => f(hwnd, item, flag),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_GetSelection(&self, hwnd: root::HWND) -> root::HTREEITEM {
        match self.pointers.TreeView_GetSelection {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_GetSelection)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_DeleteItem(&self, hwnd: root::HWND, item: root::HTREEITEM) {
        match self.pointers.TreeView_DeleteItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_DeleteItem)
            )),
            Some(f) => f(hwnd, item),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_DeleteAllItems(&self, hwnd: root::HWND) {
        match self.pointers.TreeView_DeleteAllItems {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_DeleteAllItems)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_SelectItem(&self, hwnd: root::HWND, item: root::HTREEITEM) {
        match self.pointers.TreeView_SelectItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_SelectItem)
            )),
            Some(f) => f(hwnd, item),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_GetItem(&self, hwnd: root::HWND, pitem: root::LPTVITEM) -> root::BOOL {
        match self.pointers.TreeView_GetItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_GetItem)
            )),
            Some(f) => f(hwnd, pitem),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_SetItem(&self, hwnd: root::HWND, pitem: root::LPTVITEM) -> root::BOOL {
        match self.pointers.TreeView_SetItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_SetItem)
            )),
            Some(f) => f(hwnd, pitem),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_HitTest(
        &self,
        hwnd: root::HWND,
        hti: *mut root::TVHITTESTINFO,
    ) -> root::HTREEITEM {
        match self.pointers.TreeView_HitTest {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_HitTest)
            )),
            Some(f) => f(hwnd, hti),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_SetIndent(
        &self,
        hwnd: root::HWND,
        indent: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.TreeView_SetIndent {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_SetIndent)
            )),
            Some(f) => f(hwnd, indent),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_GetChild(
        &self,
        hwnd: root::HWND,
        item: root::HTREEITEM,
    ) -> root::HTREEITEM {
        match self.pointers.TreeView_GetChild {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_GetChild)
            )),
            Some(f) => f(hwnd, item),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_GetNextSibling(
        &self,
        hwnd: root::HWND,
        item: root::HTREEITEM,
    ) -> root::HTREEITEM {
        match self.pointers.TreeView_GetNextSibling {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_GetNextSibling)
            )),
            Some(f) => f(hwnd, item),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_GetRoot(&self, hwnd: root::HWND) -> root::HTREEITEM {
        match self.pointers.TreeView_GetRoot {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_GetRoot)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_SetBkColor(&self, hwnd: root::HWND, color: ::std::os::raw::c_int) {
        match self.pointers.TreeView_SetBkColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_SetBkColor)
            )),
            Some(f) => f(hwnd, color),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TreeView_SetTextColor(&self, hwnd: root::HWND, color: ::std::os::raw::c_int) {
        match self.pointers.TreeView_SetTextColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TreeView_SetTextColor)
            )),
            Some(f) => f(hwnd, color),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetBkColor(&self, hwnd: root::HWND, color: ::std::os::raw::c_int) {
        match self.pointers.ListView_SetBkColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetBkColor)
            )),
            Some(f) => f(hwnd, color),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetTextBkColor(&self, hwnd: root::HWND, color: ::std::os::raw::c_int) {
        match self.pointers.ListView_SetTextBkColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetTextBkColor)
            )),
            Some(f) => f(hwnd, color),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetTextColor(&self, hwnd: root::HWND, color: ::std::os::raw::c_int) {
        match self.pointers.ListView_SetTextColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetTextColor)
            )),
            Some(f) => f(hwnd, color),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetGridColor(&self, hwnd: root::HWND, color: ::std::os::raw::c_int) {
        match self.pointers.ListView_SetGridColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetGridColor)
            )),
            Some(f) => f(hwnd, color),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ListView_SetSelColors(
        &self,
        hwnd: root::HWND,
        colors: *mut ::std::os::raw::c_int,
        ncolors: ::std::os::raw::c_int,
    ) {
        match self.pointers.ListView_SetSelColors {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ListView_SetSelColors)
            )),
            Some(f) => f(hwnd, colors, ncolors),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_ModalWindowStart(&self, hwnd: root::HWND) -> *mut ::std::os::raw::c_void {
        match self.pointers.SWELL_ModalWindowStart {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_ModalWindowStart)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_ModalWindowRun(
        &self,
        ctx: *mut ::std::os::raw::c_void,
        ret: *mut ::std::os::raw::c_int,
    ) -> bool {
        match self.pointers.SWELL_ModalWindowRun {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_ModalWindowRun)
            )),
            Some(f) => f(ctx, ret),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_ModalWindowEnd(&self, ctx: *mut ::std::os::raw::c_void) {
        match self.pointers.SWELL_ModalWindowEnd {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_ModalWindowEnd)
            )),
            Some(f) => f(ctx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_CloseWindow(&self, hwnd: root::HWND) {
        match self.pointers.SWELL_CloseWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_CloseWindow)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn CreatePopupMenu(&self) -> root::HMENU {
        match self.pointers.CreatePopupMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreatePopupMenu)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CreatePopupMenuEx(&self, title: *const ::std::os::raw::c_char) -> root::HMENU {
        match self.pointers.CreatePopupMenuEx {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreatePopupMenuEx)
            )),
            Some(f) => f(title),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DestroyMenu(&self, hMenu: root::HMENU) {
        match self.pointers.DestroyMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DestroyMenu)
            )),
            Some(f) => f(hMenu),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn AddMenuItem(
        &self,
        hMenu: root::HMENU,
        pos: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        tagid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.AddMenuItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(AddMenuItem)
            )),
            Some(f) => f(hMenu, pos, name, tagid),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetSubMenu(&self, hMenu: root::HMENU, pos: ::std::os::raw::c_int) -> root::HMENU {
        match self.pointers.GetSubMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetSubMenu)
            )),
            Some(f) => f(hMenu, pos),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetMenuItemCount(&self, hMenu: root::HMENU) -> ::std::os::raw::c_int {
        match self.pointers.GetMenuItemCount {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetMenuItemCount)
            )),
            Some(f) => f(hMenu),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetMenuItemID(
        &self,
        hMenu: root::HMENU,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.GetMenuItemID {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetMenuItemID)
            )),
            Some(f) => f(hMenu, pos),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetMenuItemModifier(
        &self,
        hMenu: root::HMENU,
        idx: ::std::os::raw::c_int,
        flag: ::std::os::raw::c_int,
        code: ::std::os::raw::c_int,
        mask: ::std::os::raw::c_uint,
    ) -> bool {
        match self.pointers.SetMenuItemModifier {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetMenuItemModifier)
            )),
            Some(f) => f(hMenu, idx, flag, code, mask),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetMenuItemText(
        &self,
        hMenu: root::HMENU,
        idx: ::std::os::raw::c_int,
        flag: ::std::os::raw::c_int,
        text: *const ::std::os::raw::c_char,
    ) -> bool {
        match self.pointers.SetMenuItemText {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetMenuItemText)
            )),
            Some(f) => f(hMenu, idx, flag, text),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnableMenuItem(
        &self,
        hMenu: root::HMENU,
        idx: ::std::os::raw::c_int,
        en: ::std::os::raw::c_int,
    ) -> bool {
        match self.pointers.EnableMenuItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(EnableMenuItem)
            )),
            Some(f) => f(hMenu, idx, en),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DeleteMenu(
        &self,
        hMenu: root::HMENU,
        idx: ::std::os::raw::c_int,
        flag: ::std::os::raw::c_int,
    ) -> bool {
        match self.pointers.DeleteMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DeleteMenu)
            )),
            Some(f) => f(hMenu, idx, flag),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CheckMenuItem(
        &self,
        hMenu: root::HMENU,
        idx: ::std::os::raw::c_int,
        chk: ::std::os::raw::c_int,
    ) -> bool {
        match self.pointers.CheckMenuItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CheckMenuItem)
            )),
            Some(f) => f(hMenu, idx, chk),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn InsertMenuItem(
        &self,
        hMenu: root::HMENU,
        pos: ::std::os::raw::c_int,
        byPos: root::BOOL,
        mi: *mut root::MENUITEMINFO,
    ) {
        match self.pointers.InsertMenuItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(InsertMenuItem)
            )),
            Some(f) => f(hMenu, pos, byPos, mi),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_InsertMenu(
        &self,
        menu: root::HMENU,
        pos: ::std::os::raw::c_int,
        flag: ::std::os::raw::c_uint,
        idx: root::UINT_PTR,
        str: *const ::std::os::raw::c_char,
    ) {
        match self.pointers.SWELL_InsertMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_InsertMenu)
            )),
            Some(f) => f(menu, pos, flag, idx, str),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetMenuItemInfo(
        &self,
        hMenu: root::HMENU,
        pos: ::std::os::raw::c_int,
        byPos: root::BOOL,
        mi: *mut root::MENUITEMINFO,
    ) -> root::BOOL {
        match self.pointers.GetMenuItemInfo {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetMenuItemInfo)
            )),
            Some(f) => f(hMenu, pos, byPos, mi),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetMenuItemInfo(
        &self,
        hMenu: root::HMENU,
        pos: ::std::os::raw::c_int,
        byPos: root::BOOL,
        mi: *mut root::MENUITEMINFO,
    ) -> root::BOOL {
        match self.pointers.SetMenuItemInfo {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetMenuItemInfo)
            )),
            Some(f) => f(hMenu, pos, byPos, mi),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DrawMenuBar(&self, arg1: root::HWND) {
        match self.pointers.DrawMenuBar {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DrawMenuBar)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_LoadMenu(
        &self,
        head: *mut root::SWELL_MenuResourceIndex,
        resid: *const ::std::os::raw::c_char,
    ) -> root::HMENU {
        match self.pointers.SWELL_LoadMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_LoadMenu)
            )),
            Some(f) => f(head, resid),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TrackPopupMenu(
        &self,
        hMenu: root::HMENU,
        flags: ::std::os::raw::c_int,
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
        resvd: ::std::os::raw::c_int,
        hwnd: root::HWND,
        r: *const root::RECT,
    ) -> ::std::os::raw::c_int {
        match self.pointers.TrackPopupMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(TrackPopupMenu)
            )),
            Some(f) => f(hMenu, flags, xpos, ypos, resvd, hwnd, r),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetMenuDestination(&self, menu: root::HMENU, hwnd: root::HWND) {
        match self.pointers.SWELL_SetMenuDestination {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetMenuDestination)
            )),
            Some(f) => f(menu, hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_DuplicateMenu(&self, menu: root::HMENU) -> root::HMENU {
        match self.pointers.SWELL_DuplicateMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_DuplicateMenu)
            )),
            Some(f) => f(menu),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetMenu(&self, hwnd: root::HWND, menu: root::HMENU) -> root::BOOL {
        match self.pointers.SetMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetMenu)
            )),
            Some(f) => f(hwnd, menu),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetMenu(&self, hwnd: root::HWND) -> root::HMENU {
        match self.pointers.GetMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetMenu)
            )),
            Some(f) => f(hwnd),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_GetDefaultWindowMenu(&self) -> root::HMENU {
        match self.pointers.SWELL_GetDefaultWindowMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetDefaultWindowMenu)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetDefaultWindowMenu(&self, arg1: root::HMENU) {
        match self.pointers.SWELL_SetDefaultWindowMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetDefaultWindowMenu)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_GetDefaultModalWindowMenu(&self) -> root::HMENU {
        match self.pointers.SWELL_GetDefaultModalWindowMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetDefaultModalWindowMenu)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetDefaultModalWindowMenu(&self, arg1: root::HMENU) {
        match self.pointers.SWELL_SetDefaultModalWindowMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetDefaultModalWindowMenu)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_GetCurrentMenu(&self) -> root::HMENU {
        match self.pointers.SWELL_GetCurrentMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetCurrentMenu)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetCurrentMenu(&self, arg1: root::HMENU) {
        match self.pointers.SWELL_SetCurrentMenu {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetCurrentMenu)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_DialogBox(
        &self,
        reshead: *mut root::SWELL_DialogResourceIndex,
        resid: *const ::std::os::raw::c_char,
        parent: root::HWND,
        dlgproc: root::DLGPROC,
        param: root::LPARAM,
    ) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_DialogBox {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_DialogBox)
            )),
            Some(f) => f(reshead, resid, parent, dlgproc, param),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_CreateDialog(
        &self,
        reshead: *mut root::SWELL_DialogResourceIndex,
        resid: *const ::std::os::raw::c_char,
        parent: root::HWND,
        dlgproc: root::DLGPROC,
        param: root::LPARAM,
    ) -> root::HWND {
        match self.pointers.SWELL_CreateDialog {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_CreateDialog)
            )),
            Some(f) => f(reshead, resid, parent, dlgproc, param),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_RegisterCustomControlCreator(&self, proc_: root::SWELL_ControlCreatorProc) {
        match self.pointers.SWELL_RegisterCustomControlCreator {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_RegisterCustomControlCreator)
            )),
            Some(f) => f(proc_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_UnregisterCustomControlCreator(
        &self,
        proc_: root::SWELL_ControlCreatorProc,
    ) {
        match self.pointers.SWELL_UnregisterCustomControlCreator {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_UnregisterCustomControlCreator)
            )),
            Some(f) => f(proc_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DefWindowProc(
        &self,
        hwnd: root::HWND,
        msg: root::UINT,
        wParam: root::WPARAM,
        lParam: root::LPARAM,
    ) -> root::LRESULT {
        match self.pointers.DefWindowProc {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DefWindowProc)
            )),
            Some(f) => f(hwnd, msg, wParam, lParam),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EndDialog(&self, arg1: root::HWND, arg2: ::std::os::raw::c_int) {
        match self.pointers.EndDialog {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(EndDialog)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetDefaultButtonID(
        &self,
        hwndDlg: root::HWND,
        onlyIfEnabled: bool,
    ) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_GetDefaultButtonID {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetDefaultButtonID)
            )),
            Some(f) => f(hwndDlg, onlyIfEnabled),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SendMessage(
        &self,
        arg1: root::HWND,
        arg2: root::UINT,
        arg3: root::WPARAM,
        arg4: root::LPARAM,
    ) -> root::LRESULT {
        match self.pointers.SendMessage {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SendMessage)
            )),
            Some(f) => f(arg1, arg2, arg3, arg4),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_BroadcastMessage(
        &self,
        arg1: root::UINT,
        arg2: root::WPARAM,
        arg3: root::LPARAM,
    ) {
        match self.pointers.SWELL_BroadcastMessage {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_BroadcastMessage)
            )),
            Some(f) => f(arg1, arg2, arg3),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn PostMessage(
        &self,
        hwnd: root::HWND,
        msg: root::UINT,
        wParam: root::WPARAM,
        lParam: root::LPARAM,
    ) -> root::BOOL {
        match self.pointers.PostMessage {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(PostMessage)
            )),
            Some(f) => f(hwnd, msg, wParam, lParam),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_MessageQueue_Flush(&self) {
        match self.pointers.SWELL_MessageQueue_Flush {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MessageQueue_Flush)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_MessageQueue_Clear(&self, h: root::HWND) {
        match self.pointers.SWELL_MessageQueue_Clear {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MessageQueue_Clear)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_KeyToASCII(
        &self,
        wParam: ::std::os::raw::c_int,
        lParam: ::std::os::raw::c_int,
        newflags: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_KeyToASCII {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_KeyToASCII)
            )),
            Some(f) => f(wParam, lParam, newflags),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetAsyncKeyState(&self, key: ::std::os::raw::c_int) -> root::WORD {
        match self.pointers.GetAsyncKeyState {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetAsyncKeyState)
            )),
            Some(f) => f(key),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetCursorPos(&self, pt: *mut root::POINT) {
        match self.pointers.GetCursorPos {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetCursorPos)
            )),
            Some(f) => f(pt),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetMessagePos(&self) -> root::DWORD {
        match self.pointers.GetMessagePos {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetMessagePos)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_LoadCursor(&self, idx: *const ::std::os::raw::c_char) -> root::HCURSOR {
        match self.pointers.SWELL_LoadCursor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_LoadCursor)
            )),
            Some(f) => f(idx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetCursor(&self, curs: root::HCURSOR) {
        match self.pointers.SWELL_SetCursor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetCursor)
            )),
            Some(f) => f(curs),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_EnableRightClickEmulate(&self, enable: root::BOOL) {
        match self.pointers.SWELL_EnableRightClickEmulate {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_EnableRightClickEmulate)
            )),
            Some(f) => f(enable),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_GetCursor(&self) -> root::HCURSOR {
        match self.pointers.SWELL_GetCursor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetCursor)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_GetLastSetCursor(&self) -> root::HCURSOR {
        match self.pointers.SWELL_GetLastSetCursor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetLastSetCursor)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_IsCursorVisible(&self) -> bool {
        match self.pointers.SWELL_IsCursorVisible {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_IsCursorVisible)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_ShowCursor(&self, bShow: root::BOOL) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_ShowCursor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_ShowCursor)
            )),
            Some(f) => f(bShow),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_SetCursorPos(
        &self,
        X: ::std::os::raw::c_int,
        Y: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.SWELL_SetCursorPos {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetCursorPos)
            )),
            Some(f) => f(X, Y),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetViewPort(
        &self,
        r: *mut root::RECT,
        sourcerect: *const root::RECT,
        wantWork: bool,
    ) {
        match self.pointers.SWELL_GetViewPort {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetViewPort)
            )),
            Some(f) => f(r, sourcerect, wantWork),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn OpenClipboard(&self, hwndDlg: root::HWND) -> bool {
        match self.pointers.OpenClipboard {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(OpenClipboard)
            )),
            Some(f) => f(hwndDlg),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn CloseClipboard(&self) {
        match self.pointers.CloseClipboard {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CloseClipboard)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetClipboardData(&self, type_: root::UINT) -> root::HANDLE {
        match self.pointers.GetClipboardData {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetClipboardData)
            )),
            Some(f) => f(type_),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn EmptyClipboard(&self) {
        match self.pointers.EmptyClipboard {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(EmptyClipboard)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetClipboardData(&self, type_: root::UINT, h: root::HANDLE) {
        match self.pointers.SetClipboardData {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetClipboardData)
            )),
            Some(f) => f(type_, h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn RegisterClipboardFormat(
        &self,
        desc: *const ::std::os::raw::c_char,
    ) -> root::UINT {
        match self.pointers.RegisterClipboardFormat {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(RegisterClipboardFormat)
            )),
            Some(f) => f(desc),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnumClipboardFormats(&self, lastfmt: root::UINT) -> root::UINT {
        match self.pointers.EnumClipboardFormats {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(EnumClipboardFormats)
            )),
            Some(f) => f(lastfmt),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GlobalAlloc(
        &self,
        flags: ::std::os::raw::c_int,
        sz: ::std::os::raw::c_int,
    ) -> root::HANDLE {
        match self.pointers.GlobalAlloc {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GlobalAlloc)
            )),
            Some(f) => f(flags, sz),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GlobalLock(&self, h: root::HANDLE) -> *mut ::std::os::raw::c_void {
        match self.pointers.GlobalLock {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GlobalLock)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GlobalSize(&self, h: root::HANDLE) -> ::std::os::raw::c_int {
        match self.pointers.GlobalSize {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GlobalSize)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GlobalUnlock(&self, h: root::HANDLE) {
        match self.pointers.GlobalUnlock {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GlobalUnlock)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GlobalFree(&self, h: root::HANDLE) {
        match self.pointers.GlobalFree {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GlobalFree)
            )),
            Some(f) => f(h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CreateThread(
        &self,
        TA: *mut ::std::os::raw::c_void,
        stackSize: root::DWORD,
        ThreadProc: ::std::option::Option<unsafe extern "C" fn(arg1: root::LPVOID) -> root::DWORD>,
        parm: root::LPVOID,
        cf: root::DWORD,
        tidOut: *mut root::DWORD,
    ) -> root::HANDLE {
        match self.pointers.CreateThread {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreateThread)
            )),
            Some(f) => f(TA, stackSize, ThreadProc, parm, cf, tidOut),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CreateEvent(
        &self,
        SA: *mut ::std::os::raw::c_void,
        manualReset: root::BOOL,
        initialSig: root::BOOL,
        ignored: *const ::std::os::raw::c_char,
    ) -> root::HANDLE {
        match self.pointers.CreateEvent {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreateEvent)
            )),
            Some(f) => f(SA, manualReset, initialSig, ignored),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CreateEventAsSocket(
        &self,
        SA: *mut ::std::os::raw::c_void,
        manualReset: root::BOOL,
        initialSig: root::BOOL,
        ignored: *const ::std::os::raw::c_char,
    ) -> root::HANDLE {
        match self.pointers.CreateEventAsSocket {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreateEventAsSocket)
            )),
            Some(f) => f(SA, manualReset, initialSig, ignored),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetCurrentThreadId(&self) -> root::DWORD {
        match self.pointers.GetCurrentThreadId {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetCurrentThreadId)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WaitForSingleObject(&self, hand: root::HANDLE, msTO: root::DWORD) -> root::DWORD {
        match self.pointers.WaitForSingleObject {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WaitForSingleObject)
            )),
            Some(f) => f(hand, msTO),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WaitForAnySocketObject(
        &self,
        numObjs: ::std::os::raw::c_int,
        objs: *mut root::HANDLE,
        msTO: root::DWORD,
    ) -> root::DWORD {
        match self.pointers.WaitForAnySocketObject {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(WaitForAnySocketObject)
            )),
            Some(f) => f(numObjs, objs, msTO),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CloseHandle(&self, hand: root::HANDLE) -> root::BOOL {
        match self.pointers.CloseHandle {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CloseHandle)
            )),
            Some(f) => f(hand),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetThreadPriority(
        &self,
        evt: root::HANDLE,
        prio: ::std::os::raw::c_int,
    ) -> root::BOOL {
        match self.pointers.SetThreadPriority {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetThreadPriority)
            )),
            Some(f) => f(evt, prio),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetEvent(&self, evt: root::HANDLE) -> root::BOOL {
        match self.pointers.SetEvent {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetEvent)
            )),
            Some(f) => f(evt),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ResetEvent(&self, evt: root::HANDLE) -> root::BOOL {
        match self.pointers.ResetEvent {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ResetEvent)
            )),
            Some(f) => f(evt),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_CreateProcessFromPID(&self, pid: ::std::os::raw::c_int) -> root::HANDLE {
        match self.pointers.SWELL_CreateProcessFromPID {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_CreateProcessFromPID)
            )),
            Some(f) => f(pid),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_CreateProcess(
        &self,
        exe: *const ::std::os::raw::c_char,
        nparams: ::std::os::raw::c_int,
        params: *mut *const ::std::os::raw::c_char,
    ) -> root::HANDLE {
        match self.pointers.SWELL_CreateProcess {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_CreateProcess)
            )),
            Some(f) => f(exe, nparams, params),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetProcessExitCode(&self, hand: root::HANDLE) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_GetProcessExitCode {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetProcessExitCode)
            )),
            Some(f) => f(hand),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn LoadLibraryGlobals(
        &self,
        fileName: *const ::std::os::raw::c_char,
        symbolsAsGlobals: bool,
    ) -> root::HINSTANCE {
        match self.pointers.LoadLibraryGlobals {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(LoadLibraryGlobals)
            )),
            Some(f) => f(fileName, symbolsAsGlobals),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn LoadLibrary(&self, fileName: *const ::std::os::raw::c_char) -> root::HINSTANCE {
        match self.pointers.LoadLibrary {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(LoadLibrary)
            )),
            Some(f) => f(fileName),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetProcAddress(
        &self,
        hInst: root::HINSTANCE,
        procName: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        match self.pointers.GetProcAddress {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetProcAddress)
            )),
            Some(f) => f(hInst, procName),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn FreeLibrary(&self, hInst: root::HINSTANCE) -> root::BOOL {
        match self.pointers.FreeLibrary {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(FreeLibrary)
            )),
            Some(f) => f(hInst),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetBundle(&self, hInst: root::HINSTANCE) -> *mut ::std::os::raw::c_void {
        match self.pointers.SWELL_GetBundle {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetBundle)
            )),
            Some(f) => f(hInst),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_CreateMemContext(
        &self,
        hdc: root::HDC,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    ) -> root::HDC {
        match self.pointers.SWELL_CreateMemContext {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_CreateMemContext)
            )),
            Some(f) => f(hdc, w, h),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_DeleteGfxContext(&self, arg1: root::HDC) {
        match self.pointers.SWELL_DeleteGfxContext {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_DeleteGfxContext)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetCtxGC(&self, ctx: root::HDC) -> *mut ::std::os::raw::c_void {
        match self.pointers.SWELL_GetCtxGC {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetCtxGC)
            )),
            Some(f) => f(ctx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetCtxFrameBuffer(&self, ctx: root::HDC) -> *mut ::std::os::raw::c_void {
        match self.pointers.SWELL_GetCtxFrameBuffer {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetCtxFrameBuffer)
            )),
            Some(f) => f(ctx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_PushClipRegion(&self, ctx: root::HDC) {
        match self.pointers.SWELL_PushClipRegion {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_PushClipRegion)
            )),
            Some(f) => f(ctx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetClipRegion(&self, ctx: root::HDC, r: *const root::RECT) {
        match self.pointers.SWELL_SetClipRegion {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetClipRegion)
            )),
            Some(f) => f(ctx, r),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_PopClipRegion(&self, ctx: root::HDC) {
        match self.pointers.SWELL_PopClipRegion {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_PopClipRegion)
            )),
            Some(f) => f(ctx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CreateFontIndirect(&self, arg1: *mut root::LOGFONT) -> root::HFONT {
        match self.pointers.CreateFontIndirect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreateFontIndirect)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CreateFont(
        &self,
        lfHeight: ::std::os::raw::c_int,
        lfWidth: ::std::os::raw::c_int,
        lfEscapement: ::std::os::raw::c_int,
        lfOrientation: ::std::os::raw::c_int,
        lfWeight: ::std::os::raw::c_int,
        lfItalic: ::std::os::raw::c_char,
        lfUnderline: ::std::os::raw::c_char,
        lfStrikeOut: ::std::os::raw::c_char,
        lfCharSet: ::std::os::raw::c_char,
        lfOutPrecision: ::std::os::raw::c_char,
        lfClipPrecision: ::std::os::raw::c_char,
        lfQuality: ::std::os::raw::c_char,
        lfPitchAndFamily: ::std::os::raw::c_char,
        lfFaceName: *const ::std::os::raw::c_char,
    ) -> root::HFONT {
        match self.pointers.CreateFont {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreateFont)
            )),
            Some(f) => f(
                lfHeight,
                lfWidth,
                lfEscapement,
                lfOrientation,
                lfWeight,
                lfItalic,
                lfUnderline,
                lfStrikeOut,
                lfCharSet,
                lfOutPrecision,
                lfClipPrecision,
                lfQuality,
                lfPitchAndFamily,
                lfFaceName,
            ),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn CreatePen(
        &self,
        attr: ::std::os::raw::c_int,
        wid: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
    ) -> root::HPEN {
        match self.pointers.CreatePen {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreatePen)
            )),
            Some(f) => f(attr, wid, col),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn CreateSolidBrush(&self, col: ::std::os::raw::c_int) -> root::HBRUSH {
        match self.pointers.CreateSolidBrush {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreateSolidBrush)
            )),
            Some(f) => f(col),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn CreatePenAlpha(
        &self,
        attr: ::std::os::raw::c_int,
        wid: ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        alpha: f32,
    ) -> root::HPEN {
        match self.pointers.CreatePenAlpha {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreatePenAlpha)
            )),
            Some(f) => f(attr, wid, col, alpha),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn CreateSolidBrushAlpha(&self, col: ::std::os::raw::c_int, alpha: f32) -> root::HBRUSH {
        match self.pointers.CreateSolidBrushAlpha {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreateSolidBrushAlpha)
            )),
            Some(f) => f(col, alpha),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SelectObject(&self, ctx: root::HDC, pen: root::HGDIOBJ) -> root::HGDIOBJ {
        match self.pointers.SelectObject {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SelectObject)
            )),
            Some(f) => f(ctx, pen),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetStockObject(&self, wh: ::std::os::raw::c_int) -> root::HGDIOBJ {
        match self.pointers.GetStockObject {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetStockObject)
            )),
            Some(f) => f(wh),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DeleteObject(&self, arg1: root::HGDIOBJ) {
        match self.pointers.DeleteObject {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DeleteObject)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_FillRect(&self, ctx: root::HDC, r: *const root::RECT, br: root::HBRUSH) {
        match self.pointers.SWELL_FillRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_FillRect)
            )),
            Some(f) => f(ctx, r, br),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn Rectangle(
        &self,
        ctx: root::HDC,
        l: ::std::os::raw::c_int,
        t: ::std::os::raw::c_int,
        r: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
    ) {
        match self.pointers.Rectangle {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(Rectangle)
            )),
            Some(f) => f(ctx, l, t, r, b),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn Ellipse(
        &self,
        ctx: root::HDC,
        l: ::std::os::raw::c_int,
        t: ::std::os::raw::c_int,
        r: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
    ) {
        match self.pointers.Ellipse {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(Ellipse)
            )),
            Some(f) => f(ctx, l, t, r, b),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_Polygon(
        &self,
        ctx: root::HDC,
        pts: *mut root::POINT,
        npts: ::std::os::raw::c_int,
    ) {
        match self.pointers.SWELL_Polygon {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_Polygon)
            )),
            Some(f) => f(ctx, pts, npts),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn MoveToEx(
        &self,
        ctx: root::HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        op: *mut root::POINT,
    ) {
        match self.pointers.MoveToEx {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(MoveToEx)
            )),
            Some(f) => f(ctx, x, y, op),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_LineTo(
        &self,
        ctx: root::HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) {
        match self.pointers.SWELL_LineTo {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_LineTo)
            )),
            Some(f) => f(ctx, x, y),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetPixel(
        &self,
        ctx: root::HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
    ) {
        match self.pointers.SWELL_SetPixel {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetPixel)
            )),
            Some(f) => f(ctx, x, y, c),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn PolyBezierTo(
        &self,
        ctx: root::HDC,
        pts: *mut root::POINT,
        np: ::std::os::raw::c_int,
    ) {
        match self.pointers.PolyBezierTo {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(PolyBezierTo)
            )),
            Some(f) => f(ctx, pts, np),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_DrawText(
        &self,
        ctx: root::HDC,
        buf: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        r: *mut root::RECT,
        align: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_DrawText {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_DrawText)
            )),
            Some(f) => f(ctx, buf, len, r, align),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetTextColor(&self, ctx: root::HDC, col: ::std::os::raw::c_int) {
        match self.pointers.SetTextColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetTextColor)
            )),
            Some(f) => f(ctx, col),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetTextColor(&self, ctx: root::HDC) -> ::std::os::raw::c_int {
        match self.pointers.GetTextColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetTextColor)
            )),
            Some(f) => f(ctx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetBkColor(&self, ctx: root::HDC, col: ::std::os::raw::c_int) {
        match self.pointers.SetBkColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetBkColor)
            )),
            Some(f) => f(ctx, col),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetBkMode(&self, ctx: root::HDC, col: ::std::os::raw::c_int) {
        match self.pointers.SetBkMode {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetBkMode)
            )),
            Some(f) => f(ctx, col),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetGlyphIndicesW(
        &self,
        ctx: root::HDC,
        buf: *mut u32,
        len: ::std::os::raw::c_int,
        indices: *mut ::std::os::raw::c_ushort,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.GetGlyphIndicesW {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetGlyphIndicesW)
            )),
            Some(f) => f(ctx, buf, len, indices, flags),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn RoundRect(
        &self,
        ctx: root::HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        xrnd: ::std::os::raw::c_int,
        yrnd: ::std::os::raw::c_int,
    ) {
        match self.pointers.RoundRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(RoundRect)
            )),
            Some(f) => f(ctx, x, y, x2, y2, xrnd, yrnd),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn PolyPolyline(
        &self,
        ctx: root::HDC,
        pts: *mut root::POINT,
        cnts: *mut root::DWORD,
        nseg: ::std::os::raw::c_int,
    ) {
        match self.pointers.PolyPolyline {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(PolyPolyline)
            )),
            Some(f) => f(ctx, pts, cnts, nseg),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetTextMetrics(&self, ctx: root::HDC, tm: *mut root::TEXTMETRIC) -> root::BOOL {
        match self.pointers.GetTextMetrics {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetTextMetrics)
            )),
            Some(f) => f(ctx, tm),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetTextFace(
        &self,
        ctx: root::HDC,
        nCount: ::std::os::raw::c_int,
        lpFaceName: root::LPTSTR,
    ) -> ::std::os::raw::c_int {
        match self.pointers.GetTextFace {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetTextFace)
            )),
            Some(f) => f(ctx, nCount, lpFaceName),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetObject(
        &self,
        icon: root::HICON,
        bmsz: ::std::os::raw::c_int,
        _bm: *mut ::std::os::raw::c_void,
    ) -> root::BOOL {
        match self.pointers.GetObject {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetObject)
            )),
            Some(f) => f(icon, bmsz, _bm),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CreateIconIndirect(&self, iconinfo: *mut root::ICONINFO) -> root::HICON {
        match self.pointers.CreateIconIndirect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreateIconIndirect)
            )),
            Some(f) => f(iconinfo),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn LoadNamedImage(
        &self,
        name: *const ::std::os::raw::c_char,
        alphaFromMask: bool,
    ) -> root::HICON {
        match self.pointers.LoadNamedImage {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(LoadNamedImage)
            )),
            Some(f) => f(name, alphaFromMask),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DrawImageInRect(&self, ctx: root::HDC, img: root::HICON, r: *const root::RECT) {
        match self.pointers.DrawImageInRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DrawImageInRect)
            )),
            Some(f) => f(ctx, img, r),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn BitBlt(
        &self,
        hdcOut: root::HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        hdcIn: root::HDC,
        xin: ::std::os::raw::c_int,
        yin: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) {
        match self.pointers.BitBlt {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(BitBlt)
            )),
            Some(f) => f(hdcOut, x, y, w, h, hdcIn, xin, yin, mode),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn StretchBlt(
        &self,
        hdcOut: root::HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        hdcIn: root::HDC,
        xin: ::std::os::raw::c_int,
        yin: ::std::os::raw::c_int,
        srcw: ::std::os::raw::c_int,
        srch: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) {
        match self.pointers.StretchBlt {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(StretchBlt)
            )),
            Some(f) => f(hdcOut, x, y, w, h, hdcIn, xin, yin, srcw, srch, mode),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn StretchBltFromMem(
        &self,
        hdcOut: root::HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        bits: *const ::std::os::raw::c_void,
        srcw: ::std::os::raw::c_int,
        srch: ::std::os::raw::c_int,
        srcspan: ::std::os::raw::c_int,
    ) {
        match self.pointers.StretchBltFromMem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(StretchBltFromMem)
            )),
            Some(f) => f(hdcOut, x, y, w, h, bits, srcw, srch, srcspan),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_GetScaling256(&self) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_GetScaling256 {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetScaling256)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_ExtendedAPI(
        &self,
        key: *const ::std::os::raw::c_char,
        v: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void {
        match self.pointers.SWELL_ExtendedAPI {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_ExtendedAPI)
            )),
            Some(f) => f(key, v),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetSysColor(&self, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        match self.pointers.GetSysColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetSysColor)
            )),
            Some(f) => f(idx),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CreateBitmap(
        &self,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        numplanes: ::std::os::raw::c_int,
        bitsperpixel: ::std::os::raw::c_int,
        bits: *mut ::std::os::raw::c_uchar,
    ) -> root::HBITMAP {
        match self.pointers.CreateBitmap {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(CreateBitmap)
            )),
            Some(f) => f(width, height, numplanes, bitsperpixel, bits),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetOpaque(&self, h: root::HWND, isopaque: bool) {
        match self.pointers.SetOpaque {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetOpaque)
            )),
            Some(f) => f(h, isopaque),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetAllowNoMiddleManRendering(&self, h: root::HWND, allow: bool) {
        match self.pointers.SetAllowNoMiddleManRendering {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SetAllowNoMiddleManRendering)
            )),
            Some(f) => f(h, allow),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn BeginPaint(&self, arg1: root::HWND, arg2: *mut root::PAINTSTRUCT) -> root::HDC {
        match self.pointers.BeginPaint {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(BeginPaint)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EndPaint(&self, arg1: root::HWND, arg2: *mut root::PAINTSTRUCT) -> root::BOOL {
        match self.pointers.EndPaint {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(EndPaint)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetDC(&self, arg1: root::HWND) -> root::HDC {
        match self.pointers.GetDC {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetDC)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetWindowDC(&self, arg1: root::HWND) -> root::HDC {
        match self.pointers.GetWindowDC {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetWindowDC)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ReleaseDC(&self, arg1: root::HWND, arg2: root::HDC) {
        match self.pointers.ReleaseDC {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(ReleaseDC)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_FillDialogBackground(
        &self,
        hdc: root::HDC,
        r: *const root::RECT,
        level: ::std::os::raw::c_int,
    ) {
        match self.pointers.SWELL_FillDialogBackground {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_FillDialogBackground)
            )),
            Some(f) => f(hdc, r, level),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_CloneGDIObject(&self, a: root::HGDIOBJ) -> root::HGDIOBJ {
        match self.pointers.SWELL_CloneGDIObject {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_CloneGDIObject)
            )),
            Some(f) => f(a),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn GetSystemMetrics(&self, arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        match self.pointers.GetSystemMetrics {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetSystemMetrics)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DragQueryPoint(&self, arg1: root::HDROP, arg2: root::LPPOINT) -> root::BOOL {
        match self.pointers.DragQueryPoint {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DragQueryPoint)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DragFinish(&self, arg1: root::HDROP) {
        match self.pointers.DragFinish {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DragFinish)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DragQueryFile(
        &self,
        arg1: root::HDROP,
        arg2: root::UINT,
        arg3: *mut ::std::os::raw::c_char,
        arg4: root::UINT,
    ) -> root::UINT {
        match self.pointers.DragQueryFile {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(DragQueryFile)
            )),
            Some(f) => f(arg1, arg2, arg3, arg4),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_InitiateDragDrop(
        &self,
        arg1: root::HWND,
        srcrect: *mut root::RECT,
        srcfn: *const ::std::os::raw::c_char,
        callback: ::std::option::Option<
            unsafe extern "C" fn(droppath: *const ::std::os::raw::c_char),
        >,
    ) {
        match self.pointers.SWELL_InitiateDragDrop {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_InitiateDragDrop)
            )),
            Some(f) => f(arg1, srcrect, srcfn, callback),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_InitiateDragDropOfFileList(
        &self,
        arg1: root::HWND,
        srcrect: *mut root::RECT,
        srclist: *mut *const ::std::os::raw::c_char,
        srccount: ::std::os::raw::c_int,
        icon: root::HICON,
    ) {
        match self.pointers.SWELL_InitiateDragDropOfFileList {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_InitiateDragDropOfFileList)
            )),
            Some(f) => f(arg1, srcrect, srclist, srccount, icon),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_FinishDragDrop(&self) {
        match self.pointers.SWELL_FinishDragDrop {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_FinishDragDrop)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_DrawFocusRect(
        &self,
        hwndPar: root::HWND,
        rct: *mut root::RECT,
        handle: *mut *mut ::std::os::raw::c_void,
    ) {
        match self.pointers.SWELL_DrawFocusRect {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_DrawFocusRect)
            )),
            Some(f) => f(hwndPar, rct, handle),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_MakeSetCurParms(
        &self,
        xscale: f32,
        yscale: f32,
        xtrans: f32,
        ytrans: f32,
        parent: root::HWND,
        doauto: bool,
        dosizetofit: bool,
    ) {
        match self.pointers.SWELL_MakeSetCurParms {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MakeSetCurParms)
            )),
            Some(f) => f(xscale, yscale, xtrans, ytrans, parent, doauto, dosizetofit),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_MakeButton(
        &self,
        def: ::std::os::raw::c_int,
        label: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> root::HWND {
        match self.pointers.SWELL_MakeButton {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MakeButton)
            )),
            Some(f) => f(def, label, idx, x, y, w, h, flags),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_MakeEditField(
        &self,
        idx: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> root::HWND {
        match self.pointers.SWELL_MakeEditField {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MakeEditField)
            )),
            Some(f) => f(idx, x, y, w, h, flags),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_MakeLabel(
        &self,
        align: ::std::os::raw::c_int,
        label: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> root::HWND {
        match self.pointers.SWELL_MakeLabel {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MakeLabel)
            )),
            Some(f) => f(align, label, idx, x, y, w, h, flags),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_MakeControl(
        &self,
        cname: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_int,
        classname: *const ::std::os::raw::c_char,
        style: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        exstyle: ::std::os::raw::c_int,
    ) -> root::HWND {
        match self.pointers.SWELL_MakeControl {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MakeControl)
            )),
            Some(f) => f(cname, idx, classname, style, x, y, w, h, exstyle),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_MakeCombo(
        &self,
        idx: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> root::HWND {
        match self.pointers.SWELL_MakeCombo {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MakeCombo)
            )),
            Some(f) => f(idx, x, y, w, h, flags),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_MakeGroupBox(
        &self,
        name: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        style: ::std::os::raw::c_int,
    ) -> root::HWND {
        match self.pointers.SWELL_MakeGroupBox {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MakeGroupBox)
            )),
            Some(f) => f(name, idx, x, y, w, h, style),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_MakeCheckBox(
        &self,
        name: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> root::HWND {
        match self.pointers.SWELL_MakeCheckBox {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MakeCheckBox)
            )),
            Some(f) => f(name, idx, x, y, w, h, flags),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_MakeListBox(
        &self,
        idx: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        styles: ::std::os::raw::c_int,
    ) -> root::HWND {
        match self.pointers.SWELL_MakeListBox {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_MakeListBox)
            )),
            Some(f) => f(idx, x, y, w, h, styles),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_Menu_AddMenuItem(
        &self,
        hMenu: root::HMENU,
        name: *const ::std::os::raw::c_char,
        idx: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) {
        match self.pointers.SWELL_Menu_AddMenuItem {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_Menu_AddMenuItem)
            )),
            Some(f) => f(hMenu, name, idx, flags),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GenerateMenuFromList(
        &self,
        hMenu: root::HMENU,
        list: *const ::std::os::raw::c_void,
        listsz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_GenerateMenuFromList {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GenerateMenuFromList)
            )),
            Some(f) => f(hMenu, list, listsz),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GenerateDialogFromList(
        &self,
        list: *const ::std::os::raw::c_void,
        listsz: ::std::os::raw::c_int,
    ) {
        match self.pointers.SWELL_GenerateDialogFromList {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GenerateDialogFromList)
            )),
            Some(f) => f(list, listsz),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn _controlfp(
        &self,
        flag: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        match self.pointers._controlfp {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(_controlfp)
            )),
            Some(f) => f(flag, mask),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_Internal_PostMessage_Init(&self) {
        match self.pointers.SWELL_Internal_PostMessage_Init {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_Internal_PostMessage_Init)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_LoadCursorFromFile(
        &self,
        fn_: *const ::std::os::raw::c_char,
    ) -> root::HCURSOR {
        match self.pointers.SWELL_LoadCursorFromFile {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_LoadCursorFromFile)
            )),
            Some(f) => f(fn_),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetWindowWantRaiseAmt(&self, h: root::HWND, amt: ::std::os::raw::c_int) {
        match self.pointers.SWELL_SetWindowWantRaiseAmt {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetWindowWantRaiseAmt)
            )),
            Some(f) => f(h, amt),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetWindowWantRaiseAmt(&self, arg1: root::HWND) -> ::std::os::raw::c_int {
        match self.pointers.SWELL_GetWindowWantRaiseAmt {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetWindowWantRaiseAmt)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetListViewFastClickMask(
        &self,
        hList: root::HWND,
        mask: ::std::os::raw::c_int,
    ) {
        match self.pointers.SWELL_SetListViewFastClickMask {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetListViewFastClickMask)
            )),
            Some(f) => f(hList, mask),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetTempPath(&self, sz: ::std::os::raw::c_int, buf: *mut ::std::os::raw::c_char) {
        match self.pointers.GetTempPath {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetTempPath)
            )),
            Some(f) => f(sz, buf),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_initargs(
        &self,
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
    ) {
        match self.pointers.SWELL_initargs {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_initargs)
            )),
            Some(f) => f(argc, argv),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_RunMessageLoop(&self) {
        match self.pointers.SWELL_RunMessageLoop {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_RunMessageLoop)
            )),
            Some(f) => f(),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_CreateXBridgeWindow(
        &self,
        viewpar: root::HWND,
        wref: *mut *mut ::std::os::raw::c_void,
        arg1: *mut root::RECT,
    ) -> root::HWND {
        match self.pointers.SWELL_CreateXBridgeWindow {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_CreateXBridgeWindow)
            )),
            Some(f) => f(viewpar, wref, arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GenerateGUID(&self, g: *mut ::std::os::raw::c_void) -> bool {
        match self.pointers.SWELL_GenerateGUID {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GenerateGUID)
            )),
            Some(f) => f(g),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnumChildWindows(
        &self,
        hwnd: root::HWND,
        cwEnumFunc: ::std::option::Option<
            unsafe extern "C" fn(arg1: root::HWND, arg2: root::LPARAM) -> root::BOOL,
        >,
        lParam: root::LPARAM,
    ) -> root::BOOL {
        match self.pointers.EnumChildWindows {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(EnumChildWindows)
            )),
            Some(f) => f(hwnd, cwEnumFunc, lParam),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_IsGroupBox(&self, arg1: root::HWND) -> root::BOOL {
        match self.pointers.SWELL_IsGroupBox {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_IsGroupBox)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_IsButton(&self, arg1: root::HWND) -> root::BOOL {
        match self.pointers.SWELL_IsButton {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_IsButton)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_IsStaticText(&self, arg1: root::HWND) -> root::BOOL {
        match self.pointers.SWELL_IsStaticText {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_IsStaticText)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_GetDesiredControlSize(&self, hwnd: root::HWND, r: *mut root::RECT) {
        match self.pointers.SWELL_GetDesiredControlSize {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_GetDesiredControlSize)
            )),
            Some(f) => f(hwnd, r),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn AddFontResourceEx(
        &self,
        str: root::LPCTSTR,
        fl: root::DWORD,
        pdv: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        match self.pointers.AddFontResourceEx {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(AddFontResourceEx)
            )),
            Some(f) => f(str, fl, pdv),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_Register_Cursor_Resource(
        &self,
        idx: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        hotspot_x: ::std::os::raw::c_int,
        hotspot_y: ::std::os::raw::c_int,
    ) {
        match self.pointers.SWELL_Register_Cursor_Resource {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_Register_Cursor_Resource)
            )),
            Some(f) => f(idx, name, hotspot_x, hotspot_y),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_ChooseColor(
        &self,
        arg1: root::HWND,
        arg2: *mut ::std::os::raw::c_int,
        ncustom: ::std::os::raw::c_int,
        custom: *mut ::std::os::raw::c_int,
    ) -> bool {
        match self.pointers.SWELL_ChooseColor {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_ChooseColor)
            )),
            Some(f) => f(arg1, arg2, ncustom, custom),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_ChooseFont(&self, arg1: root::HWND, arg2: *mut root::LOGFONT) -> bool {
        match self.pointers.SWELL_ChooseFont {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_ChooseFont)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsWindowEnabled(&self, arg1: root::HWND) -> bool {
        match self.pointers.IsWindowEnabled {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(IsWindowEnabled)
            )),
            Some(f) => f(arg1),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetClassName(
        &self,
        arg1: root::HWND,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        match self.pointers.GetClassName {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(GetClassName)
            )),
            Some(f) => f(arg1, arg2, arg3),
        }
    }
    #[cfg(target_family = "unix")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SWELL_SetClassName(&self, arg1: root::HWND, arg2: *const ::std::os::raw::c_char) {
        match self.pointers.SWELL_SetClassName {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_SetClassName)
            )),
            Some(f) => f(arg1, arg2),
        }
    }
    #[cfg(target_family = "unix")]
    pub fn SWELL_osx_is_dark_mode(&self, mode: ::std::os::raw::c_int) -> bool {
        match self.pointers.SWELL_osx_is_dark_mode {
            None => panic!(format!(
                "Attempt to use a function that has not been loaded: {}",
                stringify!(SWELL_osx_is_dark_mode)
            )),
            Some(f) => f(mode),
        }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetDlgItem(&self, arg1: root::HWND, arg2: ::std::os::raw::c_int) -> root::HWND {
        unsafe { windows::GetDlgItem(arg1, arg2) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ShowWindow(&self, arg1: root::HWND, arg2: ::std::os::raw::c_int) {
        unsafe { windows::ShowWindow(arg1, arg2) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DestroyWindow(&self, hwnd: root::HWND) {
        unsafe { windows::DestroyWindow(hwnd) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetDlgItemInt(
        &self,
        arg1: root::HWND,
        idx: ::std::os::raw::c_int,
        val: ::std::os::raw::c_int,
        issigned: ::std::os::raw::c_int,
    ) -> root::BOOL {
        unsafe { windows::SetDlgItemInt(arg1, idx, val, issigned) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetDlgItemInt(
        &self,
        arg1: root::HWND,
        idx: ::std::os::raw::c_int,
        translated: *mut root::BOOL,
        issigned: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { windows::GetDlgItemInt(arg1, idx, translated, issigned) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CheckDlgButton(
        &self,
        hwnd: root::HWND,
        idx: ::std::os::raw::c_int,
        check: ::std::os::raw::c_int,
    ) {
        unsafe { windows::CheckDlgButton(hwnd, idx, check) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsDlgButtonChecked(
        &self,
        hwnd: root::HWND,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { windows::IsDlgButtonChecked(hwnd, idx) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnableWindow(&self, hwnd: root::HWND, enable: ::std::os::raw::c_int) {
        unsafe { windows::EnableWindow(hwnd, enable) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetFocus(&self, hwnd: root::HWND) {
        unsafe { windows::SetFocus(hwnd) }
    }
    #[cfg(target_family = "windows")]
    pub fn GetFocus(&self) -> root::HWND {
        unsafe { windows::GetFocus() }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetForegroundWindow(&self, hwnd: root::HWND) {
        unsafe { windows::SetForegroundWindow(hwnd) }
    }
    #[cfg(target_family = "windows")]
    pub fn GetForegroundWindow(&self) -> root::HWND {
        unsafe { windows::GetForegroundWindow() }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetCapture(&self, hwnd: root::HWND) -> root::HWND {
        unsafe { windows::SetCapture(hwnd) }
    }
    #[cfg(target_family = "windows")]
    pub fn GetCapture(&self) -> root::HWND {
        unsafe { windows::GetCapture() }
    }
    #[cfg(target_family = "windows")]
    pub fn ReleaseCapture(&self) {
        unsafe { windows::ReleaseCapture() }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsChild(
        &self,
        hwndParent: root::HWND,
        hwndChild: root::HWND,
    ) -> ::std::os::raw::c_int {
        unsafe { windows::IsChild(hwndParent, hwndChild) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetParent(&self, hwnd: root::HWND) -> root::HWND {
        unsafe { windows::GetParent(hwnd) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetParent(&self, hwnd: root::HWND, newPar: root::HWND) -> root::HWND {
        unsafe { windows::SetParent(hwnd, newPar) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetWindow(&self, hwnd: root::HWND, what: ::std::os::raw::c_int) -> root::HWND {
        unsafe { windows::GetWindow(hwnd, what) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnumWindows(
        &self,
        proc_: ::std::option::Option<
            unsafe extern "C" fn(arg1: root::HWND, arg2: root::LPARAM) -> root::BOOL,
        >,
        lp: root::LPARAM,
    ) -> root::BOOL {
        unsafe { windows::EnumWindows(proc_, lp) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ClientToScreen(&self, hwnd: root::HWND, p: *mut root::POINT) {
        unsafe { windows::ClientToScreen(hwnd, p) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ScreenToClient(&self, hwnd: root::HWND, p: *mut root::POINT) {
        unsafe { windows::ScreenToClient(hwnd, p) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetWindowRect(&self, hwnd: root::HWND, r: *mut root::RECT) -> bool {
        unsafe { windows::GetWindowRect(hwnd, r) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetClientRect(&self, hwnd: root::HWND, r: *mut root::RECT) {
        unsafe { windows::GetClientRect(hwnd, r) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn WindowFromPoint(&self, p: root::POINT) -> root::HWND {
        unsafe { windows::WindowFromPoint(p) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetWindowPos(
        &self,
        hwnd: root::HWND,
        unused: root::HWND,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) {
        unsafe { windows::SetWindowPos(hwnd, unused, x, y, cx, cy, flags) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn InvalidateRect(
        &self,
        hwnd: root::HWND,
        r: *const root::RECT,
        eraseBk: ::std::os::raw::c_int,
    ) -> root::BOOL {
        unsafe { windows::InvalidateRect(hwnd, r, eraseBk) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ScrollWindow(
        &self,
        hwnd: root::HWND,
        xamt: ::std::os::raw::c_int,
        yamt: ::std::os::raw::c_int,
        lpRect: *const root::RECT,
        lpClipRect: *const root::RECT,
    ) -> root::BOOL {
        unsafe { windows::ScrollWindow(hwnd, xamt, yamt, lpRect, lpClipRect) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsWindowVisible(&self, hwnd: root::HWND) -> bool {
        unsafe { windows::IsWindowVisible(hwnd) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsWindow(&self, hwnd: root::HWND) -> bool {
        unsafe { windows::IsWindow(hwnd) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetTimer(
        &self,
        hwnd: root::HWND,
        timerid: root::UINT_PTR,
        rate: root::UINT,
        tProc: root::TIMERPROC,
    ) -> root::UINT_PTR {
        unsafe { windows::SetTimer(hwnd, timerid, rate, tProc) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn KillTimer(&self, hwnd: root::HWND, timerid: root::UINT_PTR) -> root::BOOL {
        unsafe { windows::KillTimer(hwnd, timerid) }
    }
    #[cfg(target_family = "windows")]
    pub fn CreatePopupMenu(&self) -> root::HMENU {
        unsafe { windows::CreatePopupMenu() }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DestroyMenu(&self, hMenu: root::HMENU) {
        unsafe { windows::DestroyMenu(hMenu) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetSubMenu(&self, hMenu: root::HMENU, pos: ::std::os::raw::c_int) -> root::HMENU {
        unsafe { windows::GetSubMenu(hMenu, pos) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetMenuItemCount(&self, hMenu: root::HMENU) -> ::std::os::raw::c_int {
        unsafe { windows::GetMenuItemCount(hMenu) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetMenuItemID(
        &self,
        hMenu: root::HMENU,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe { windows::GetMenuItemID(hMenu, pos) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnableMenuItem(
        &self,
        hMenu: root::HMENU,
        idx: ::std::os::raw::c_int,
        en: ::std::os::raw::c_int,
    ) -> bool {
        unsafe { windows::EnableMenuItem(hMenu, idx, en) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DeleteMenu(
        &self,
        hMenu: root::HMENU,
        idx: ::std::os::raw::c_int,
        flag: ::std::os::raw::c_int,
    ) -> bool {
        unsafe { windows::DeleteMenu(hMenu, idx, flag) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CheckMenuItem(
        &self,
        hMenu: root::HMENU,
        idx: ::std::os::raw::c_int,
        chk: ::std::os::raw::c_int,
    ) -> bool {
        unsafe { windows::CheckMenuItem(hMenu, idx, chk) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn DrawMenuBar(&self, arg1: root::HWND) {
        unsafe { windows::DrawMenuBar(arg1) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn TrackPopupMenu(
        &self,
        hMenu: root::HMENU,
        flags: ::std::os::raw::c_int,
        xpos: ::std::os::raw::c_int,
        ypos: ::std::os::raw::c_int,
        resvd: ::std::os::raw::c_int,
        hwnd: root::HWND,
        r: *const root::RECT,
    ) -> ::std::os::raw::c_int {
        unsafe { windows::TrackPopupMenu(hMenu, flags, xpos, ypos, resvd, hwnd, r) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetMenu(&self, hwnd: root::HWND, menu: root::HMENU) -> root::BOOL {
        unsafe { windows::SetMenu(hwnd, menu) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetMenu(&self, hwnd: root::HWND) -> root::HMENU {
        unsafe { windows::GetMenu(hwnd) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EndDialog(&self, arg1: root::HWND, arg2: ::std::os::raw::c_int) {
        unsafe { windows::EndDialog(arg1, arg2) }
    }
    #[cfg(target_family = "windows")]
    pub fn GetAsyncKeyState(&self, key: ::std::os::raw::c_int) -> root::WORD {
        unsafe { windows::GetAsyncKeyState(key) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetCursorPos(&self, pt: *mut root::POINT) {
        unsafe { windows::GetCursorPos(pt) }
    }
    #[cfg(target_family = "windows")]
    pub fn GetMessagePos(&self) -> root::DWORD {
        unsafe { windows::GetMessagePos() }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn OpenClipboard(&self, hwndDlg: root::HWND) -> bool {
        unsafe { windows::OpenClipboard(hwndDlg) }
    }
    #[cfg(target_family = "windows")]
    pub fn CloseClipboard(&self) {
        unsafe { windows::CloseClipboard() }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetClipboardData(&self, type_: root::UINT) -> root::HANDLE {
        unsafe { windows::GetClipboardData(type_) }
    }
    #[cfg(target_family = "windows")]
    pub fn EmptyClipboard(&self) {
        unsafe { windows::EmptyClipboard() }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetClipboardData(&self, type_: root::UINT, h: root::HANDLE) {
        unsafe { windows::SetClipboardData(type_, h) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnumClipboardFormats(&self, lastfmt: root::UINT) -> root::UINT {
        unsafe { windows::EnumClipboardFormats(lastfmt) }
    }
    #[cfg(target_family = "windows")]
    pub fn GlobalAlloc(
        &self,
        flags: ::std::os::raw::c_int,
        sz: ::std::os::raw::c_int,
    ) -> root::HANDLE {
        unsafe { windows::GlobalAlloc(flags, sz) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GlobalLock(&self, h: root::HANDLE) -> *mut ::std::os::raw::c_void {
        unsafe { windows::GlobalLock(h) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GlobalUnlock(&self, h: root::HANDLE) {
        unsafe { windows::GlobalUnlock(h) }
    }
    #[cfg(target_family = "windows")]
    pub fn CreateSolidBrush(&self, col: ::std::os::raw::c_int) -> root::HBRUSH {
        unsafe { windows::CreateSolidBrush(col) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetTextColor(&self, ctx: root::HDC, col: ::std::os::raw::c_int) {
        unsafe { windows::SetTextColor(ctx, col) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetBkColor(&self, ctx: root::HDC, col: ::std::os::raw::c_int) {
        unsafe { windows::SetBkColor(ctx, col) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn SetBkMode(&self, ctx: root::HDC, col: ::std::os::raw::c_int) {
        unsafe { windows::SetBkMode(ctx, col) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn CreateIconIndirect(&self, iconinfo: *mut root::ICONINFO) -> root::HICON {
        unsafe { windows::CreateIconIndirect(iconinfo) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn BitBlt(
        &self,
        hdcOut: root::HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        hdcIn: root::HDC,
        xin: ::std::os::raw::c_int,
        yin: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) {
        unsafe { windows::BitBlt(hdcOut, x, y, w, h, hdcIn, xin, yin, mode) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn StretchBlt(
        &self,
        hdcOut: root::HDC,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        hdcIn: root::HDC,
        xin: ::std::os::raw::c_int,
        yin: ::std::os::raw::c_int,
        srcw: ::std::os::raw::c_int,
        srch: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) {
        unsafe { windows::StretchBlt(hdcOut, x, y, w, h, hdcIn, xin, yin, srcw, srch, mode) }
    }
    #[cfg(target_family = "windows")]
    pub fn GetSysColor(&self, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { windows::GetSysColor(idx) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn BeginPaint(&self, arg1: root::HWND, arg2: *mut root::PAINTSTRUCT) -> root::HDC {
        unsafe { windows::BeginPaint(arg1, arg2) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EndPaint(&self, arg1: root::HWND, arg2: *mut root::PAINTSTRUCT) -> root::BOOL {
        unsafe { windows::EndPaint(arg1, arg2) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetDC(&self, arg1: root::HWND) -> root::HDC {
        unsafe { windows::GetDC(arg1) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn GetWindowDC(&self, arg1: root::HWND) -> root::HDC {
        unsafe { windows::GetWindowDC(arg1) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn ReleaseDC(&self, arg1: root::HWND, arg2: root::HDC) {
        unsafe { windows::ReleaseDC(arg1, arg2) }
    }
    #[cfg(target_family = "windows")]
    pub fn GetSystemMetrics(&self, arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe { windows::GetSystemMetrics(arg1) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn EnumChildWindows(
        &self,
        hwnd: root::HWND,
        cwEnumFunc: ::std::option::Option<
            unsafe extern "C" fn(arg1: root::HWND, arg2: root::LPARAM) -> root::BOOL,
        >,
        lParam: root::LPARAM,
    ) -> root::BOOL {
        unsafe { windows::EnumChildWindows(hwnd, cwEnumFunc, lParam) }
    }
    #[cfg(target_family = "windows")]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" REAPER can crash if you pass an invalid pointer."]
    pub unsafe fn IsWindowEnabled(&self, arg1: root::HWND) -> bool {
        unsafe { windows::IsWindowEnabled(arg1) }
    }
}
#[doc = r" Container for the SWELL function pointers."]
#[derive(Copy, Clone, Default)]
pub struct SwellFunctionPointers {
    pub(crate) loaded_count: u32,
    pub lstrcpyn: Option<
        unsafe extern "C" fn(
            dest: *mut ::std::os::raw::c_char,
            src: *const ::std::os::raw::c_char,
            l: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub MulDiv: Option<
        extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub Sleep: Option<extern "C" fn(ms: ::std::os::raw::c_int)>,
    pub GetTickCount: Option<extern "C" fn() -> root::DWORD>,
    pub GetFileTime: Option<
        unsafe extern "C" fn(
            filedes: ::std::os::raw::c_int,
            lpCreationTime: *mut root::FILETIME,
            lpLastAccessTime: *mut root::FILETIME,
            lpLastWriteTime: *mut root::FILETIME,
        ) -> root::BOOL,
    >,
    pub WritePrivateProfileString: Option<
        unsafe extern "C" fn(
            appname: *const ::std::os::raw::c_char,
            keyname: *const ::std::os::raw::c_char,
            val: *const ::std::os::raw::c_char,
            fn_: *const ::std::os::raw::c_char,
        ) -> root::BOOL,
    >,
    pub GetPrivateProfileString: Option<
        unsafe extern "C" fn(
            appname: *const ::std::os::raw::c_char,
            keyname: *const ::std::os::raw::c_char,
            def: *const ::std::os::raw::c_char,
            ret: *mut ::std::os::raw::c_char,
            retsize: ::std::os::raw::c_int,
            fn_: *const ::std::os::raw::c_char,
        ) -> root::DWORD,
    >,
    pub GetPrivateProfileInt: Option<
        unsafe extern "C" fn(
            appname: *const ::std::os::raw::c_char,
            keyname: *const ::std::os::raw::c_char,
            def: ::std::os::raw::c_int,
            fn_: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub GetPrivateProfileStruct: Option<
        unsafe extern "C" fn(
            appname: *const ::std::os::raw::c_char,
            keyname: *const ::std::os::raw::c_char,
            buf: *mut ::std::os::raw::c_void,
            bufsz: ::std::os::raw::c_int,
            fn_: *const ::std::os::raw::c_char,
        ) -> root::BOOL,
    >,
    pub WritePrivateProfileStruct: Option<
        unsafe extern "C" fn(
            appname: *const ::std::os::raw::c_char,
            keyname: *const ::std::os::raw::c_char,
            buf: *const ::std::os::raw::c_void,
            bufsz: ::std::os::raw::c_int,
            fn_: *const ::std::os::raw::c_char,
        ) -> root::BOOL,
    >,
    pub WritePrivateProfileSection: Option<
        unsafe extern "C" fn(
            appname: *const ::std::os::raw::c_char,
            strings: *const ::std::os::raw::c_char,
            fn_: *const ::std::os::raw::c_char,
        ) -> root::BOOL,
    >,
    pub GetPrivateProfileSection: Option<
        unsafe extern "C" fn(
            appname: *const ::std::os::raw::c_char,
            strout: *mut ::std::os::raw::c_char,
            strout_len: root::DWORD,
            fn_: *const ::std::os::raw::c_char,
        ) -> root::DWORD,
    >,
    pub GetModuleFileName: Option<
        unsafe extern "C" fn(
            hInst: root::HINSTANCE,
            fn_: *mut ::std::os::raw::c_char,
            nSize: root::DWORD,
        ) -> root::DWORD,
    >,
    pub SWELL_PtInRect:
        Option<unsafe extern "C" fn(r: *const root::RECT, p: root::POINT) -> root::BOOL>,
    pub ShellExecute: Option<
        unsafe extern "C" fn(
            hwndDlg: root::HWND,
            action: *const ::std::os::raw::c_char,
            content1: *const ::std::os::raw::c_char,
            content2: *const ::std::os::raw::c_char,
            content3: *const ::std::os::raw::c_char,
            blah: ::std::os::raw::c_int,
        ) -> root::BOOL,
    >,
    pub MessageBox: Option<
        unsafe extern "C" fn(
            hwndParent: root::HWND,
            text: *const ::std::os::raw::c_char,
            caption: *const ::std::os::raw::c_char,
            type_: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub BrowseForFiles: Option<
        unsafe extern "C" fn(
            text: *const ::std::os::raw::c_char,
            initialdir: *const ::std::os::raw::c_char,
            initialfile: *const ::std::os::raw::c_char,
            allowmul: bool,
            extlist: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub BrowseForSaveFile: Option<
        unsafe extern "C" fn(
            text: *const ::std::os::raw::c_char,
            initialdir: *const ::std::os::raw::c_char,
            initialfile: *const ::std::os::raw::c_char,
            extlist: *const ::std::os::raw::c_char,
            fn_: *mut ::std::os::raw::c_char,
            fnsize: ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub BrowseForDirectory: Option<
        unsafe extern "C" fn(
            text: *const ::std::os::raw::c_char,
            initialdir: *const ::std::os::raw::c_char,
            fn_: *mut ::std::os::raw::c_char,
            fnsize: ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub BrowseFile_SetTemplate: Option<
        unsafe extern "C" fn(
            dlgid: *const ::std::os::raw::c_char,
            dlgProc: root::DLGPROC,
            reshead: *mut root::SWELL_DialogResourceIndex,
        ),
    >,
    pub GetDlgItem:
        Option<unsafe extern "C" fn(arg1: root::HWND, arg2: ::std::os::raw::c_int) -> root::HWND>,
    pub ShowWindow: Option<unsafe extern "C" fn(arg1: root::HWND, arg2: ::std::os::raw::c_int)>,
    pub DestroyWindow: Option<unsafe extern "C" fn(hwnd: root::HWND)>,
    pub SWELL_GetGestureInfo: Option<
        unsafe extern "C" fn(lParam: root::LPARAM, gi: *mut root::GESTUREINFO) -> root::BOOL,
    >,
    pub SWELL_HideApp: Option<extern "C" fn()>,
    pub SetDlgItemText: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            idx: ::std::os::raw::c_int,
            text: *const ::std::os::raw::c_char,
        ) -> root::BOOL,
    >,
    pub SetDlgItemInt: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            idx: ::std::os::raw::c_int,
            val: ::std::os::raw::c_int,
            issigned: ::std::os::raw::c_int,
        ) -> root::BOOL,
    >,
    pub GetDlgItemInt: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            idx: ::std::os::raw::c_int,
            translated: *mut root::BOOL,
            issigned: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub GetDlgItemText: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            idx: ::std::os::raw::c_int,
            text: *mut ::std::os::raw::c_char,
            textlen: ::std::os::raw::c_int,
        ) -> root::BOOL,
    >,
    pub CheckDlgButton: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            idx: ::std::os::raw::c_int,
            check: ::std::os::raw::c_int,
        ),
    >,
    pub IsDlgButtonChecked: Option<
        unsafe extern "C" fn(hwnd: root::HWND, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub EnableWindow: Option<unsafe extern "C" fn(hwnd: root::HWND, enable: ::std::os::raw::c_int)>,
    pub SetFocus: Option<unsafe extern "C" fn(hwnd: root::HWND)>,
    pub GetFocus: Option<extern "C" fn() -> root::HWND>,
    pub SetForegroundWindow: Option<unsafe extern "C" fn(hwnd: root::HWND)>,
    pub GetForegroundWindow: Option<extern "C" fn() -> root::HWND>,
    pub SetCapture: Option<unsafe extern "C" fn(hwnd: root::HWND) -> root::HWND>,
    pub GetCapture: Option<extern "C" fn() -> root::HWND>,
    pub ReleaseCapture: Option<extern "C" fn()>,
    pub IsChild: Option<
        unsafe extern "C" fn(
            hwndParent: root::HWND,
            hwndChild: root::HWND,
        ) -> ::std::os::raw::c_int,
    >,
    pub GetParent: Option<unsafe extern "C" fn(hwnd: root::HWND) -> root::HWND>,
    pub SetParent: Option<unsafe extern "C" fn(hwnd: root::HWND, newPar: root::HWND) -> root::HWND>,
    pub GetWindow:
        Option<unsafe extern "C" fn(hwnd: root::HWND, what: ::std::os::raw::c_int) -> root::HWND>,
    pub EnumWindows: Option<
        unsafe extern "C" fn(
            proc_: ::std::option::Option<
                unsafe extern "C" fn(arg1: root::HWND, arg2: root::LPARAM) -> root::BOOL,
            >,
            lp: root::LPARAM,
        ) -> root::BOOL,
    >,
    pub FindWindowEx: Option<
        unsafe extern "C" fn(
            par: root::HWND,
            lastw: root::HWND,
            classname: *const ::std::os::raw::c_char,
            title: *const ::std::os::raw::c_char,
        ) -> root::HWND,
    >,
    pub ClientToScreen: Option<unsafe extern "C" fn(hwnd: root::HWND, p: *mut root::POINT)>,
    pub ScreenToClient: Option<unsafe extern "C" fn(hwnd: root::HWND, p: *mut root::POINT)>,
    pub GetWindowRect: Option<unsafe extern "C" fn(hwnd: root::HWND, r: *mut root::RECT) -> bool>,
    pub GetWindowContentViewRect:
        Option<unsafe extern "C" fn(hwnd: root::HWND, r: *mut root::RECT)>,
    pub GetClientRect: Option<unsafe extern "C" fn(hwnd: root::HWND, r: *mut root::RECT)>,
    pub WindowFromPoint: Option<unsafe extern "C" fn(p: root::POINT) -> root::HWND>,
    pub WinOffsetRect: Option<
        unsafe extern "C" fn(
            lprc: root::LPRECT,
            dx: ::std::os::raw::c_int,
            dy: ::std::os::raw::c_int,
        ) -> root::BOOL,
    >,
    pub WinSetRect: Option<
        unsafe extern "C" fn(
            lprc: root::LPRECT,
            xLeft: ::std::os::raw::c_int,
            yTop: ::std::os::raw::c_int,
            xRight: ::std::os::raw::c_int,
            yBottom: ::std::os::raw::c_int,
        ) -> root::BOOL,
    >,
    pub WinUnionRect: Option<
        unsafe extern "C" fn(out: *mut root::RECT, in1: *const root::RECT, in2: *const root::RECT),
    >,
    pub WinIntersectRect: Option<
        unsafe extern "C" fn(
            out: *mut root::RECT,
            in1: *const root::RECT,
            in2: *const root::RECT,
        ) -> ::std::os::raw::c_int,
    >,
    pub SetWindowPos: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            unused: root::HWND,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            cx: ::std::os::raw::c_int,
            cy: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ),
    >,
    pub SWELL_SetWindowLevel: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            newlevel: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub InvalidateRect: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            r: *const root::RECT,
            eraseBk: ::std::os::raw::c_int,
        ) -> root::BOOL,
    >,
    pub UpdateWindow: Option<unsafe extern "C" fn(hwnd: root::HWND)>,
    pub GetWindowLong: Option<
        unsafe extern "C" fn(hwnd: root::HWND, idx: ::std::os::raw::c_int) -> root::LONG_PTR,
    >,
    pub SetWindowLong: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            idx: ::std::os::raw::c_int,
            val: root::LONG_PTR,
        ) -> root::LONG_PTR,
    >,
    pub ScrollWindow: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            xamt: ::std::os::raw::c_int,
            yamt: ::std::os::raw::c_int,
            lpRect: *const root::RECT,
            lpClipRect: *const root::RECT,
        ) -> root::BOOL,
    >,
    pub EnumPropsEx: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            arg2: root::PROPENUMPROCEX,
            arg3: root::LPARAM,
        ) -> ::std::os::raw::c_int,
    >,
    pub GetProp: Option<
        unsafe extern "C" fn(arg1: root::HWND, arg2: *const ::std::os::raw::c_char) -> root::HANDLE,
    >,
    pub SetProp: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            arg2: *const ::std::os::raw::c_char,
            arg3: root::HANDLE,
        ) -> root::BOOL,
    >,
    pub RemoveProp: Option<
        unsafe extern "C" fn(arg1: root::HWND, arg2: *const ::std::os::raw::c_char) -> root::HANDLE,
    >,
    pub IsWindowVisible: Option<unsafe extern "C" fn(hwnd: root::HWND) -> bool>,
    pub IsWindow: Option<unsafe extern "C" fn(hwnd: root::HWND) -> bool>,
    pub SetTimer: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            timerid: root::UINT_PTR,
            rate: root::UINT,
            tProc: root::TIMERPROC,
        ) -> root::UINT_PTR,
    >,
    pub KillTimer:
        Option<unsafe extern "C" fn(hwnd: root::HWND, timerid: root::UINT_PTR) -> root::BOOL>,
    pub ListView_SetExtendedListViewStyleEx: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            mask: ::std::os::raw::c_int,
            style: ::std::os::raw::c_int,
        ),
    >,
    pub ListView_InsertColumn: Option<
        unsafe extern "C" fn(h: root::HWND, pos: ::std::os::raw::c_int, lvc: *const root::LVCOLUMN),
    >,
    pub ListView_DeleteColumn:
        Option<unsafe extern "C" fn(h: root::HWND, pos: ::std::os::raw::c_int) -> bool>,
    pub ListView_SetColumn: Option<
        unsafe extern "C" fn(h: root::HWND, pos: ::std::os::raw::c_int, lvc: *const root::LVCOLUMN),
    >,
    pub ListView_GetColumnWidth: Option<
        unsafe extern "C" fn(h: root::HWND, pos: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub ListView_InsertItem: Option<
        unsafe extern "C" fn(h: root::HWND, item: *const root::LVITEM) -> ::std::os::raw::c_int,
    >,
    pub ListView_SetItemText: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            ipos: ::std::os::raw::c_int,
            cpos: ::std::os::raw::c_int,
            txt: *const ::std::os::raw::c_char,
        ),
    >,
    pub ListView_SetItem:
        Option<unsafe extern "C" fn(h: root::HWND, item: *mut root::LVITEM) -> bool>,
    pub ListView_GetNextItem: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            istart: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub ListView_GetItem:
        Option<unsafe extern "C" fn(h: root::HWND, item: *mut root::LVITEM) -> bool>,
    pub ListView_GetItemState: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            ipos: ::std::os::raw::c_int,
            mask: root::UINT,
        ) -> ::std::os::raw::c_int,
    >,
    pub ListView_DeleteItem:
        Option<unsafe extern "C" fn(h: root::HWND, ipos: ::std::os::raw::c_int)>,
    pub ListView_DeleteAllItems: Option<unsafe extern "C" fn(h: root::HWND)>,
    pub ListView_GetSelectedCount:
        Option<unsafe extern "C" fn(h: root::HWND) -> ::std::os::raw::c_int>,
    pub ListView_GetItemCount: Option<unsafe extern "C" fn(h: root::HWND) -> ::std::os::raw::c_int>,
    pub ListView_GetSelectionMark:
        Option<unsafe extern "C" fn(h: root::HWND) -> ::std::os::raw::c_int>,
    pub ListView_SetColumnWidth: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            colpos: ::std::os::raw::c_int,
            wid: ::std::os::raw::c_int,
        ),
    >,
    pub ListView_SetItemState: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            item: ::std::os::raw::c_int,
            state: root::UINT,
            statemask: root::UINT,
        ) -> bool,
    >,
    pub ListView_RedrawItems: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            startitem: ::std::os::raw::c_int,
            enditem: ::std::os::raw::c_int,
        ),
    >,
    pub ListView_SetItemCount:
        Option<unsafe extern "C" fn(h: root::HWND, cnt: ::std::os::raw::c_int)>,
    pub ListView_EnsureVisible:
        Option<unsafe extern "C" fn(h: root::HWND, i: ::std::os::raw::c_int, pok: root::BOOL)>,
    pub ListView_GetSubItemRect: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            item: ::std::os::raw::c_int,
            subitem: ::std::os::raw::c_int,
            code: ::std::os::raw::c_int,
            r: *mut root::RECT,
        ) -> bool,
    >,
    pub ListView_SetImageList: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            imagelist: root::HIMAGELIST,
            which: ::std::os::raw::c_int,
        ),
    >,
    pub ListView_HitTest: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            pinf: *mut root::LVHITTESTINFO,
        ) -> ::std::os::raw::c_int,
    >,
    pub ListView_SubItemHitTest: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            pinf: *mut root::LVHITTESTINFO,
        ) -> ::std::os::raw::c_int,
    >,
    pub ListView_GetItemText: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            item: ::std::os::raw::c_int,
            subitem: ::std::os::raw::c_int,
            text: *mut ::std::os::raw::c_char,
            textmax: ::std::os::raw::c_int,
        ),
    >,
    pub ListView_SortItems: Option<
        unsafe extern "C" fn(hwnd: root::HWND, compf: root::PFNLVCOMPARE, parm: root::LPARAM),
    >,
    pub ListView_GetItemRect: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            item: ::std::os::raw::c_int,
            r: *mut root::RECT,
            code: ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub ListView_Scroll: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            xscroll: ::std::os::raw::c_int,
            yscroll: ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub ListView_GetTopIndex: Option<unsafe extern "C" fn(h: root::HWND) -> ::std::os::raw::c_int>,
    pub ListView_GetCountPerPage:
        Option<unsafe extern "C" fn(h: root::HWND) -> ::std::os::raw::c_int>,
    pub ListView_SetColumnOrderArray: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            cnt: ::std::os::raw::c_int,
            arr: *mut ::std::os::raw::c_int,
        ) -> root::BOOL,
    >,
    pub ListView_GetColumnOrderArray: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            cnt: ::std::os::raw::c_int,
            arr: *mut ::std::os::raw::c_int,
        ) -> root::BOOL,
    >,
    pub ListView_GetHeader: Option<unsafe extern "C" fn(h: root::HWND) -> root::HWND>,
    pub Header_GetItemCount: Option<unsafe extern "C" fn(h: root::HWND) -> ::std::os::raw::c_int>,
    pub Header_GetItem: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            col: ::std::os::raw::c_int,
            hi: *mut root::HDITEM,
        ) -> root::BOOL,
    >,
    pub Header_SetItem: Option<
        unsafe extern "C" fn(
            h: root::HWND,
            col: ::std::os::raw::c_int,
            hi: *mut root::HDITEM,
        ) -> root::BOOL,
    >,
    pub SWELL_GetListViewHeaderHeight:
        Option<unsafe extern "C" fn(h: root::HWND) -> ::std::os::raw::c_int>,
    pub ImageList_CreateEx: Option<extern "C" fn() -> root::HIMAGELIST>,
    pub ImageList_Remove: Option<
        unsafe extern "C" fn(list: root::HIMAGELIST, idx: ::std::os::raw::c_int) -> root::BOOL,
    >,
    pub ImageList_ReplaceIcon: Option<
        unsafe extern "C" fn(
            list: root::HIMAGELIST,
            offset: ::std::os::raw::c_int,
            image: root::HICON,
        ) -> ::std::os::raw::c_int,
    >,
    pub ImageList_Add: Option<
        unsafe extern "C" fn(
            list: root::HIMAGELIST,
            image: root::HBITMAP,
            mask: root::HBITMAP,
        ) -> ::std::os::raw::c_int,
    >,
    pub ImageList_Destroy: Option<unsafe extern "C" fn(arg1: root::HIMAGELIST)>,
    pub TabCtrl_GetItemCount:
        Option<unsafe extern "C" fn(hwnd: root::HWND) -> ::std::os::raw::c_int>,
    pub TabCtrl_DeleteItem:
        Option<unsafe extern "C" fn(hwnd: root::HWND, idx: ::std::os::raw::c_int) -> root::BOOL>,
    pub TabCtrl_InsertItem: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            idx: ::std::os::raw::c_int,
            item: *mut root::TCITEM,
        ) -> ::std::os::raw::c_int,
    >,
    pub TabCtrl_SetCurSel: Option<
        unsafe extern "C" fn(hwnd: root::HWND, idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub TabCtrl_GetCurSel: Option<unsafe extern "C" fn(hwnd: root::HWND) -> ::std::os::raw::c_int>,
    pub TabCtrl_AdjustRect: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            fLarger: root::BOOL,
            r: *mut root::RECT,
        ) -> root::BOOL,
    >,
    pub TreeView_InsertItem: Option<
        unsafe extern "C" fn(hwnd: root::HWND, ins: *mut root::TV_INSERTSTRUCT) -> root::HTREEITEM,
    >,
    pub TreeView_Expand: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            item: root::HTREEITEM,
            flag: root::UINT,
        ) -> root::BOOL,
    >,
    pub TreeView_GetSelection: Option<unsafe extern "C" fn(hwnd: root::HWND) -> root::HTREEITEM>,
    pub TreeView_DeleteItem: Option<unsafe extern "C" fn(hwnd: root::HWND, item: root::HTREEITEM)>,
    pub TreeView_DeleteAllItems: Option<unsafe extern "C" fn(hwnd: root::HWND)>,
    pub TreeView_SelectItem: Option<unsafe extern "C" fn(hwnd: root::HWND, item: root::HTREEITEM)>,
    pub TreeView_GetItem:
        Option<unsafe extern "C" fn(hwnd: root::HWND, pitem: root::LPTVITEM) -> root::BOOL>,
    pub TreeView_SetItem:
        Option<unsafe extern "C" fn(hwnd: root::HWND, pitem: root::LPTVITEM) -> root::BOOL>,
    pub TreeView_HitTest: Option<
        unsafe extern "C" fn(hwnd: root::HWND, hti: *mut root::TVHITTESTINFO) -> root::HTREEITEM,
    >,
    pub TreeView_SetIndent:
        Option<unsafe extern "C" fn(hwnd: root::HWND, indent: ::std::os::raw::c_int) -> root::BOOL>,
    pub TreeView_GetChild:
        Option<unsafe extern "C" fn(hwnd: root::HWND, item: root::HTREEITEM) -> root::HTREEITEM>,
    pub TreeView_GetNextSibling:
        Option<unsafe extern "C" fn(hwnd: root::HWND, item: root::HTREEITEM) -> root::HTREEITEM>,
    pub TreeView_GetRoot: Option<unsafe extern "C" fn(hwnd: root::HWND) -> root::HTREEITEM>,
    pub TreeView_SetBkColor:
        Option<unsafe extern "C" fn(hwnd: root::HWND, color: ::std::os::raw::c_int)>,
    pub TreeView_SetTextColor:
        Option<unsafe extern "C" fn(hwnd: root::HWND, color: ::std::os::raw::c_int)>,
    pub ListView_SetBkColor:
        Option<unsafe extern "C" fn(hwnd: root::HWND, color: ::std::os::raw::c_int)>,
    pub ListView_SetTextBkColor:
        Option<unsafe extern "C" fn(hwnd: root::HWND, color: ::std::os::raw::c_int)>,
    pub ListView_SetTextColor:
        Option<unsafe extern "C" fn(hwnd: root::HWND, color: ::std::os::raw::c_int)>,
    pub ListView_SetGridColor:
        Option<unsafe extern "C" fn(hwnd: root::HWND, color: ::std::os::raw::c_int)>,
    pub ListView_SetSelColors: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            colors: *mut ::std::os::raw::c_int,
            ncolors: ::std::os::raw::c_int,
        ),
    >,
    pub SWELL_ModalWindowStart:
        Option<unsafe extern "C" fn(hwnd: root::HWND) -> *mut ::std::os::raw::c_void>,
    pub SWELL_ModalWindowRun: Option<
        unsafe extern "C" fn(
            ctx: *mut ::std::os::raw::c_void,
            ret: *mut ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub SWELL_ModalWindowEnd: Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>,
    pub SWELL_CloseWindow: Option<unsafe extern "C" fn(hwnd: root::HWND)>,
    pub CreatePopupMenu: Option<extern "C" fn() -> root::HMENU>,
    pub CreatePopupMenuEx:
        Option<unsafe extern "C" fn(title: *const ::std::os::raw::c_char) -> root::HMENU>,
    pub DestroyMenu: Option<unsafe extern "C" fn(hMenu: root::HMENU)>,
    pub AddMenuItem: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            pos: ::std::os::raw::c_int,
            name: *const ::std::os::raw::c_char,
            tagid: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub GetSubMenu:
        Option<unsafe extern "C" fn(hMenu: root::HMENU, pos: ::std::os::raw::c_int) -> root::HMENU>,
    pub GetMenuItemCount: Option<unsafe extern "C" fn(hMenu: root::HMENU) -> ::std::os::raw::c_int>,
    pub GetMenuItemID: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            pos: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub SetMenuItemModifier: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            idx: ::std::os::raw::c_int,
            flag: ::std::os::raw::c_int,
            code: ::std::os::raw::c_int,
            mask: ::std::os::raw::c_uint,
        ) -> bool,
    >,
    pub SetMenuItemText: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            idx: ::std::os::raw::c_int,
            flag: ::std::os::raw::c_int,
            text: *const ::std::os::raw::c_char,
        ) -> bool,
    >,
    pub EnableMenuItem: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            idx: ::std::os::raw::c_int,
            en: ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub DeleteMenu: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            idx: ::std::os::raw::c_int,
            flag: ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub CheckMenuItem: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            idx: ::std::os::raw::c_int,
            chk: ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub InsertMenuItem: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            pos: ::std::os::raw::c_int,
            byPos: root::BOOL,
            mi: *mut root::MENUITEMINFO,
        ),
    >,
    pub SWELL_InsertMenu: Option<
        unsafe extern "C" fn(
            menu: root::HMENU,
            pos: ::std::os::raw::c_int,
            flag: ::std::os::raw::c_uint,
            idx: root::UINT_PTR,
            str: *const ::std::os::raw::c_char,
        ),
    >,
    pub GetMenuItemInfo: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            pos: ::std::os::raw::c_int,
            byPos: root::BOOL,
            mi: *mut root::MENUITEMINFO,
        ) -> root::BOOL,
    >,
    pub SetMenuItemInfo: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            pos: ::std::os::raw::c_int,
            byPos: root::BOOL,
            mi: *mut root::MENUITEMINFO,
        ) -> root::BOOL,
    >,
    pub DrawMenuBar: Option<unsafe extern "C" fn(arg1: root::HWND)>,
    pub SWELL_LoadMenu: Option<
        unsafe extern "C" fn(
            head: *mut root::SWELL_MenuResourceIndex,
            resid: *const ::std::os::raw::c_char,
        ) -> root::HMENU,
    >,
    pub TrackPopupMenu: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            flags: ::std::os::raw::c_int,
            xpos: ::std::os::raw::c_int,
            ypos: ::std::os::raw::c_int,
            resvd: ::std::os::raw::c_int,
            hwnd: root::HWND,
            r: *const root::RECT,
        ) -> ::std::os::raw::c_int,
    >,
    pub SWELL_SetMenuDestination: Option<unsafe extern "C" fn(menu: root::HMENU, hwnd: root::HWND)>,
    pub SWELL_DuplicateMenu: Option<unsafe extern "C" fn(menu: root::HMENU) -> root::HMENU>,
    pub SetMenu: Option<unsafe extern "C" fn(hwnd: root::HWND, menu: root::HMENU) -> root::BOOL>,
    pub GetMenu: Option<unsafe extern "C" fn(hwnd: root::HWND) -> root::HMENU>,
    pub SWELL_GetDefaultWindowMenu: Option<extern "C" fn() -> root::HMENU>,
    pub SWELL_SetDefaultWindowMenu: Option<unsafe extern "C" fn(arg1: root::HMENU)>,
    pub SWELL_GetDefaultModalWindowMenu: Option<extern "C" fn() -> root::HMENU>,
    pub SWELL_SetDefaultModalWindowMenu: Option<unsafe extern "C" fn(arg1: root::HMENU)>,
    pub SWELL_GetCurrentMenu: Option<extern "C" fn() -> root::HMENU>,
    pub SWELL_SetCurrentMenu: Option<unsafe extern "C" fn(arg1: root::HMENU)>,
    pub SWELL_DialogBox: Option<
        unsafe extern "C" fn(
            reshead: *mut root::SWELL_DialogResourceIndex,
            resid: *const ::std::os::raw::c_char,
            parent: root::HWND,
            dlgproc: root::DLGPROC,
            param: root::LPARAM,
        ) -> ::std::os::raw::c_int,
    >,
    pub SWELL_CreateDialog: Option<
        unsafe extern "C" fn(
            reshead: *mut root::SWELL_DialogResourceIndex,
            resid: *const ::std::os::raw::c_char,
            parent: root::HWND,
            dlgproc: root::DLGPROC,
            param: root::LPARAM,
        ) -> root::HWND,
    >,
    pub SWELL_RegisterCustomControlCreator:
        Option<unsafe extern "C" fn(proc_: root::SWELL_ControlCreatorProc)>,
    pub SWELL_UnregisterCustomControlCreator:
        Option<unsafe extern "C" fn(proc_: root::SWELL_ControlCreatorProc)>,
    pub DefWindowProc: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            msg: root::UINT,
            wParam: root::WPARAM,
            lParam: root::LPARAM,
        ) -> root::LRESULT,
    >,
    pub EndDialog: Option<unsafe extern "C" fn(arg1: root::HWND, arg2: ::std::os::raw::c_int)>,
    pub SWELL_GetDefaultButtonID: Option<
        unsafe extern "C" fn(hwndDlg: root::HWND, onlyIfEnabled: bool) -> ::std::os::raw::c_int,
    >,
    pub SendMessage: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            arg2: root::UINT,
            arg3: root::WPARAM,
            arg4: root::LPARAM,
        ) -> root::LRESULT,
    >,
    pub SWELL_BroadcastMessage:
        Option<unsafe extern "C" fn(arg1: root::UINT, arg2: root::WPARAM, arg3: root::LPARAM)>,
    pub PostMessage: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            msg: root::UINT,
            wParam: root::WPARAM,
            lParam: root::LPARAM,
        ) -> root::BOOL,
    >,
    pub SWELL_MessageQueue_Flush: Option<extern "C" fn()>,
    pub SWELL_MessageQueue_Clear: Option<unsafe extern "C" fn(h: root::HWND)>,
    pub SWELL_KeyToASCII: Option<
        unsafe extern "C" fn(
            wParam: ::std::os::raw::c_int,
            lParam: ::std::os::raw::c_int,
            newflags: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub GetAsyncKeyState: Option<extern "C" fn(key: ::std::os::raw::c_int) -> root::WORD>,
    pub GetCursorPos: Option<unsafe extern "C" fn(pt: *mut root::POINT)>,
    pub GetMessagePos: Option<extern "C" fn() -> root::DWORD>,
    pub SWELL_LoadCursor:
        Option<unsafe extern "C" fn(idx: *const ::std::os::raw::c_char) -> root::HCURSOR>,
    pub SWELL_SetCursor: Option<unsafe extern "C" fn(curs: root::HCURSOR)>,
    pub SWELL_EnableRightClickEmulate: Option<unsafe extern "C" fn(enable: root::BOOL)>,
    pub SWELL_GetCursor: Option<extern "C" fn() -> root::HCURSOR>,
    pub SWELL_GetLastSetCursor: Option<extern "C" fn() -> root::HCURSOR>,
    pub SWELL_IsCursorVisible: Option<extern "C" fn() -> bool>,
    pub SWELL_ShowCursor: Option<unsafe extern "C" fn(bShow: root::BOOL) -> ::std::os::raw::c_int>,
    pub SWELL_SetCursorPos:
        Option<extern "C" fn(X: ::std::os::raw::c_int, Y: ::std::os::raw::c_int) -> root::BOOL>,
    pub SWELL_GetViewPort: Option<
        unsafe extern "C" fn(r: *mut root::RECT, sourcerect: *const root::RECT, wantWork: bool),
    >,
    pub OpenClipboard: Option<unsafe extern "C" fn(hwndDlg: root::HWND) -> bool>,
    pub CloseClipboard: Option<extern "C" fn()>,
    pub GetClipboardData: Option<unsafe extern "C" fn(type_: root::UINT) -> root::HANDLE>,
    pub EmptyClipboard: Option<extern "C" fn()>,
    pub SetClipboardData: Option<unsafe extern "C" fn(type_: root::UINT, h: root::HANDLE)>,
    pub RegisterClipboardFormat:
        Option<unsafe extern "C" fn(desc: *const ::std::os::raw::c_char) -> root::UINT>,
    pub EnumClipboardFormats: Option<unsafe extern "C" fn(lastfmt: root::UINT) -> root::UINT>,
    pub GlobalAlloc: Option<
        extern "C" fn(flags: ::std::os::raw::c_int, sz: ::std::os::raw::c_int) -> root::HANDLE,
    >,
    pub GlobalLock: Option<unsafe extern "C" fn(h: root::HANDLE) -> *mut ::std::os::raw::c_void>,
    pub GlobalSize: Option<unsafe extern "C" fn(h: root::HANDLE) -> ::std::os::raw::c_int>,
    pub GlobalUnlock: Option<unsafe extern "C" fn(h: root::HANDLE)>,
    pub GlobalFree: Option<unsafe extern "C" fn(h: root::HANDLE)>,
    pub CreateThread: Option<
        unsafe extern "C" fn(
            TA: *mut ::std::os::raw::c_void,
            stackSize: root::DWORD,
            ThreadProc: ::std::option::Option<
                unsafe extern "C" fn(arg1: root::LPVOID) -> root::DWORD,
            >,
            parm: root::LPVOID,
            cf: root::DWORD,
            tidOut: *mut root::DWORD,
        ) -> root::HANDLE,
    >,
    pub CreateEvent: Option<
        unsafe extern "C" fn(
            SA: *mut ::std::os::raw::c_void,
            manualReset: root::BOOL,
            initialSig: root::BOOL,
            ignored: *const ::std::os::raw::c_char,
        ) -> root::HANDLE,
    >,
    pub CreateEventAsSocket: Option<
        unsafe extern "C" fn(
            SA: *mut ::std::os::raw::c_void,
            manualReset: root::BOOL,
            initialSig: root::BOOL,
            ignored: *const ::std::os::raw::c_char,
        ) -> root::HANDLE,
    >,
    pub GetCurrentThreadId: Option<extern "C" fn() -> root::DWORD>,
    pub WaitForSingleObject:
        Option<unsafe extern "C" fn(hand: root::HANDLE, msTO: root::DWORD) -> root::DWORD>,
    pub WaitForAnySocketObject: Option<
        unsafe extern "C" fn(
            numObjs: ::std::os::raw::c_int,
            objs: *mut root::HANDLE,
            msTO: root::DWORD,
        ) -> root::DWORD,
    >,
    pub CloseHandle: Option<unsafe extern "C" fn(hand: root::HANDLE) -> root::BOOL>,
    pub SetThreadPriority:
        Option<unsafe extern "C" fn(evt: root::HANDLE, prio: ::std::os::raw::c_int) -> root::BOOL>,
    pub SetEvent: Option<unsafe extern "C" fn(evt: root::HANDLE) -> root::BOOL>,
    pub ResetEvent: Option<unsafe extern "C" fn(evt: root::HANDLE) -> root::BOOL>,
    pub SWELL_CreateProcessFromPID:
        Option<extern "C" fn(pid: ::std::os::raw::c_int) -> root::HANDLE>,
    pub SWELL_CreateProcess: Option<
        unsafe extern "C" fn(
            exe: *const ::std::os::raw::c_char,
            nparams: ::std::os::raw::c_int,
            params: *mut *const ::std::os::raw::c_char,
        ) -> root::HANDLE,
    >,
    pub SWELL_GetProcessExitCode:
        Option<unsafe extern "C" fn(hand: root::HANDLE) -> ::std::os::raw::c_int>,
    pub LoadLibraryGlobals: Option<
        unsafe extern "C" fn(
            fileName: *const ::std::os::raw::c_char,
            symbolsAsGlobals: bool,
        ) -> root::HINSTANCE,
    >,
    pub LoadLibrary:
        Option<unsafe extern "C" fn(fileName: *const ::std::os::raw::c_char) -> root::HINSTANCE>,
    pub GetProcAddress: Option<
        unsafe extern "C" fn(
            hInst: root::HINSTANCE,
            procName: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub FreeLibrary: Option<unsafe extern "C" fn(hInst: root::HINSTANCE) -> root::BOOL>,
    pub SWELL_GetBundle:
        Option<unsafe extern "C" fn(hInst: root::HINSTANCE) -> *mut ::std::os::raw::c_void>,
    pub SWELL_CreateMemContext: Option<
        unsafe extern "C" fn(
            hdc: root::HDC,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
        ) -> root::HDC,
    >,
    pub SWELL_DeleteGfxContext: Option<unsafe extern "C" fn(arg1: root::HDC)>,
    pub SWELL_GetCtxGC: Option<unsafe extern "C" fn(ctx: root::HDC) -> *mut ::std::os::raw::c_void>,
    pub SWELL_GetCtxFrameBuffer:
        Option<unsafe extern "C" fn(ctx: root::HDC) -> *mut ::std::os::raw::c_void>,
    pub SWELL_PushClipRegion: Option<unsafe extern "C" fn(ctx: root::HDC)>,
    pub SWELL_SetClipRegion: Option<unsafe extern "C" fn(ctx: root::HDC, r: *const root::RECT)>,
    pub SWELL_PopClipRegion: Option<unsafe extern "C" fn(ctx: root::HDC)>,
    pub CreateFontIndirect: Option<unsafe extern "C" fn(arg1: *mut root::LOGFONT) -> root::HFONT>,
    pub CreateFont: Option<
        unsafe extern "C" fn(
            lfHeight: ::std::os::raw::c_int,
            lfWidth: ::std::os::raw::c_int,
            lfEscapement: ::std::os::raw::c_int,
            lfOrientation: ::std::os::raw::c_int,
            lfWeight: ::std::os::raw::c_int,
            lfItalic: ::std::os::raw::c_char,
            lfUnderline: ::std::os::raw::c_char,
            lfStrikeOut: ::std::os::raw::c_char,
            lfCharSet: ::std::os::raw::c_char,
            lfOutPrecision: ::std::os::raw::c_char,
            lfClipPrecision: ::std::os::raw::c_char,
            lfQuality: ::std::os::raw::c_char,
            lfPitchAndFamily: ::std::os::raw::c_char,
            lfFaceName: *const ::std::os::raw::c_char,
        ) -> root::HFONT,
    >,
    pub CreatePen: Option<
        extern "C" fn(
            attr: ::std::os::raw::c_int,
            wid: ::std::os::raw::c_int,
            col: ::std::os::raw::c_int,
        ) -> root::HPEN,
    >,
    pub CreateSolidBrush: Option<extern "C" fn(col: ::std::os::raw::c_int) -> root::HBRUSH>,
    pub CreatePenAlpha: Option<
        extern "C" fn(
            attr: ::std::os::raw::c_int,
            wid: ::std::os::raw::c_int,
            col: ::std::os::raw::c_int,
            alpha: f32,
        ) -> root::HPEN,
    >,
    pub CreateSolidBrushAlpha:
        Option<extern "C" fn(col: ::std::os::raw::c_int, alpha: f32) -> root::HBRUSH>,
    pub SelectObject:
        Option<unsafe extern "C" fn(ctx: root::HDC, pen: root::HGDIOBJ) -> root::HGDIOBJ>,
    pub GetStockObject: Option<extern "C" fn(wh: ::std::os::raw::c_int) -> root::HGDIOBJ>,
    pub DeleteObject: Option<unsafe extern "C" fn(arg1: root::HGDIOBJ)>,
    pub SWELL_FillRect:
        Option<unsafe extern "C" fn(ctx: root::HDC, r: *const root::RECT, br: root::HBRUSH)>,
    pub Rectangle: Option<
        unsafe extern "C" fn(
            ctx: root::HDC,
            l: ::std::os::raw::c_int,
            t: ::std::os::raw::c_int,
            r: ::std::os::raw::c_int,
            b: ::std::os::raw::c_int,
        ),
    >,
    pub Ellipse: Option<
        unsafe extern "C" fn(
            ctx: root::HDC,
            l: ::std::os::raw::c_int,
            t: ::std::os::raw::c_int,
            r: ::std::os::raw::c_int,
            b: ::std::os::raw::c_int,
        ),
    >,
    pub SWELL_Polygon: Option<
        unsafe extern "C" fn(ctx: root::HDC, pts: *mut root::POINT, npts: ::std::os::raw::c_int),
    >,
    pub MoveToEx: Option<
        unsafe extern "C" fn(
            ctx: root::HDC,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            op: *mut root::POINT,
        ),
    >,
    pub SWELL_LineTo: Option<
        unsafe extern "C" fn(ctx: root::HDC, x: ::std::os::raw::c_int, y: ::std::os::raw::c_int),
    >,
    pub SWELL_SetPixel: Option<
        unsafe extern "C" fn(
            ctx: root::HDC,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            c: ::std::os::raw::c_int,
        ),
    >,
    pub PolyBezierTo: Option<
        unsafe extern "C" fn(ctx: root::HDC, pts: *mut root::POINT, np: ::std::os::raw::c_int),
    >,
    pub SWELL_DrawText: Option<
        unsafe extern "C" fn(
            ctx: root::HDC,
            buf: *const ::std::os::raw::c_char,
            len: ::std::os::raw::c_int,
            r: *mut root::RECT,
            align: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub SetTextColor: Option<unsafe extern "C" fn(ctx: root::HDC, col: ::std::os::raw::c_int)>,
    pub GetTextColor: Option<unsafe extern "C" fn(ctx: root::HDC) -> ::std::os::raw::c_int>,
    pub SetBkColor: Option<unsafe extern "C" fn(ctx: root::HDC, col: ::std::os::raw::c_int)>,
    pub SetBkMode: Option<unsafe extern "C" fn(ctx: root::HDC, col: ::std::os::raw::c_int)>,
    pub GetGlyphIndicesW: Option<
        unsafe extern "C" fn(
            ctx: root::HDC,
            buf: *mut u32,
            len: ::std::os::raw::c_int,
            indices: *mut ::std::os::raw::c_ushort,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub RoundRect: Option<
        unsafe extern "C" fn(
            ctx: root::HDC,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            x2: ::std::os::raw::c_int,
            y2: ::std::os::raw::c_int,
            xrnd: ::std::os::raw::c_int,
            yrnd: ::std::os::raw::c_int,
        ),
    >,
    pub PolyPolyline: Option<
        unsafe extern "C" fn(
            ctx: root::HDC,
            pts: *mut root::POINT,
            cnts: *mut root::DWORD,
            nseg: ::std::os::raw::c_int,
        ),
    >,
    pub GetTextMetrics:
        Option<unsafe extern "C" fn(ctx: root::HDC, tm: *mut root::TEXTMETRIC) -> root::BOOL>,
    pub GetTextFace: Option<
        unsafe extern "C" fn(
            ctx: root::HDC,
            nCount: ::std::os::raw::c_int,
            lpFaceName: root::LPTSTR,
        ) -> ::std::os::raw::c_int,
    >,
    pub GetObject: Option<
        unsafe extern "C" fn(
            icon: root::HICON,
            bmsz: ::std::os::raw::c_int,
            _bm: *mut ::std::os::raw::c_void,
        ) -> root::BOOL,
    >,
    pub CreateIconIndirect:
        Option<unsafe extern "C" fn(iconinfo: *mut root::ICONINFO) -> root::HICON>,
    pub LoadNamedImage: Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            alphaFromMask: bool,
        ) -> root::HICON,
    >,
    pub DrawImageInRect:
        Option<unsafe extern "C" fn(ctx: root::HDC, img: root::HICON, r: *const root::RECT)>,
    pub BitBlt: Option<
        unsafe extern "C" fn(
            hdcOut: root::HDC,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            hdcIn: root::HDC,
            xin: ::std::os::raw::c_int,
            yin: ::std::os::raw::c_int,
            mode: ::std::os::raw::c_int,
        ),
    >,
    pub StretchBlt: Option<
        unsafe extern "C" fn(
            hdcOut: root::HDC,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            hdcIn: root::HDC,
            xin: ::std::os::raw::c_int,
            yin: ::std::os::raw::c_int,
            srcw: ::std::os::raw::c_int,
            srch: ::std::os::raw::c_int,
            mode: ::std::os::raw::c_int,
        ),
    >,
    pub StretchBltFromMem: Option<
        unsafe extern "C" fn(
            hdcOut: root::HDC,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            bits: *const ::std::os::raw::c_void,
            srcw: ::std::os::raw::c_int,
            srch: ::std::os::raw::c_int,
            srcspan: ::std::os::raw::c_int,
        ),
    >,
    pub SWELL_GetScaling256: Option<extern "C" fn() -> ::std::os::raw::c_int>,
    pub SWELL_ExtendedAPI: Option<
        unsafe extern "C" fn(
            key: *const ::std::os::raw::c_char,
            v: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub GetSysColor: Option<extern "C" fn(idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int>,
    pub CreateBitmap: Option<
        unsafe extern "C" fn(
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            numplanes: ::std::os::raw::c_int,
            bitsperpixel: ::std::os::raw::c_int,
            bits: *mut ::std::os::raw::c_uchar,
        ) -> root::HBITMAP,
    >,
    pub SetOpaque: Option<unsafe extern "C" fn(h: root::HWND, isopaque: bool)>,
    pub SetAllowNoMiddleManRendering: Option<unsafe extern "C" fn(h: root::HWND, allow: bool)>,
    pub BeginPaint:
        Option<unsafe extern "C" fn(arg1: root::HWND, arg2: *mut root::PAINTSTRUCT) -> root::HDC>,
    pub EndPaint:
        Option<unsafe extern "C" fn(arg1: root::HWND, arg2: *mut root::PAINTSTRUCT) -> root::BOOL>,
    pub GetDC: Option<unsafe extern "C" fn(arg1: root::HWND) -> root::HDC>,
    pub GetWindowDC: Option<unsafe extern "C" fn(arg1: root::HWND) -> root::HDC>,
    pub ReleaseDC: Option<unsafe extern "C" fn(arg1: root::HWND, arg2: root::HDC)>,
    pub SWELL_FillDialogBackground: Option<
        unsafe extern "C" fn(hdc: root::HDC, r: *const root::RECT, level: ::std::os::raw::c_int),
    >,
    pub SWELL_CloneGDIObject: Option<unsafe extern "C" fn(a: root::HGDIOBJ) -> root::HGDIOBJ>,
    pub GetSystemMetrics:
        Option<extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int>,
    pub DragQueryPoint:
        Option<unsafe extern "C" fn(arg1: root::HDROP, arg2: root::LPPOINT) -> root::BOOL>,
    pub DragFinish: Option<unsafe extern "C" fn(arg1: root::HDROP)>,
    pub DragQueryFile: Option<
        unsafe extern "C" fn(
            arg1: root::HDROP,
            arg2: root::UINT,
            arg3: *mut ::std::os::raw::c_char,
            arg4: root::UINT,
        ) -> root::UINT,
    >,
    pub SWELL_InitiateDragDrop: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            srcrect: *mut root::RECT,
            srcfn: *const ::std::os::raw::c_char,
            callback: ::std::option::Option<
                unsafe extern "C" fn(droppath: *const ::std::os::raw::c_char),
            >,
        ),
    >,
    pub SWELL_InitiateDragDropOfFileList: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            srcrect: *mut root::RECT,
            srclist: *mut *const ::std::os::raw::c_char,
            srccount: ::std::os::raw::c_int,
            icon: root::HICON,
        ),
    >,
    pub SWELL_FinishDragDrop: Option<extern "C" fn()>,
    pub SWELL_DrawFocusRect: Option<
        unsafe extern "C" fn(
            hwndPar: root::HWND,
            rct: *mut root::RECT,
            handle: *mut *mut ::std::os::raw::c_void,
        ),
    >,
    pub SWELL_MakeSetCurParms: Option<
        unsafe extern "C" fn(
            xscale: f32,
            yscale: f32,
            xtrans: f32,
            ytrans: f32,
            parent: root::HWND,
            doauto: bool,
            dosizetofit: bool,
        ),
    >,
    pub SWELL_MakeButton: Option<
        unsafe extern "C" fn(
            def: ::std::os::raw::c_int,
            label: *const ::std::os::raw::c_char,
            idx: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> root::HWND,
    >,
    pub SWELL_MakeEditField: Option<
        extern "C" fn(
            idx: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> root::HWND,
    >,
    pub SWELL_MakeLabel: Option<
        unsafe extern "C" fn(
            align: ::std::os::raw::c_int,
            label: *const ::std::os::raw::c_char,
            idx: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> root::HWND,
    >,
    pub SWELL_MakeControl: Option<
        unsafe extern "C" fn(
            cname: *const ::std::os::raw::c_char,
            idx: ::std::os::raw::c_int,
            classname: *const ::std::os::raw::c_char,
            style: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            exstyle: ::std::os::raw::c_int,
        ) -> root::HWND,
    >,
    pub SWELL_MakeCombo: Option<
        extern "C" fn(
            idx: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> root::HWND,
    >,
    pub SWELL_MakeGroupBox: Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            idx: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            style: ::std::os::raw::c_int,
        ) -> root::HWND,
    >,
    pub SWELL_MakeCheckBox: Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            idx: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> root::HWND,
    >,
    pub SWELL_MakeListBox: Option<
        extern "C" fn(
            idx: ::std::os::raw::c_int,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            styles: ::std::os::raw::c_int,
        ) -> root::HWND,
    >,
    pub SWELL_Menu_AddMenuItem: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            name: *const ::std::os::raw::c_char,
            idx: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_uint,
        ),
    >,
    pub SWELL_GenerateMenuFromList: Option<
        unsafe extern "C" fn(
            hMenu: root::HMENU,
            list: *const ::std::os::raw::c_void,
            listsz: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub SWELL_GenerateDialogFromList: Option<
        unsafe extern "C" fn(list: *const ::std::os::raw::c_void, listsz: ::std::os::raw::c_int),
    >,
    pub _controlfp: Option<
        extern "C" fn(
            flag: ::std::os::raw::c_uint,
            mask: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
    pub SWELL_Internal_PostMessage_Init: Option<extern "C" fn()>,
    pub SWELL_LoadCursorFromFile:
        Option<unsafe extern "C" fn(fn_: *const ::std::os::raw::c_char) -> root::HCURSOR>,
    pub SWELL_SetWindowWantRaiseAmt:
        Option<unsafe extern "C" fn(h: root::HWND, amt: ::std::os::raw::c_int)>,
    pub SWELL_GetWindowWantRaiseAmt:
        Option<unsafe extern "C" fn(arg1: root::HWND) -> ::std::os::raw::c_int>,
    pub SWELL_SetListViewFastClickMask:
        Option<unsafe extern "C" fn(hList: root::HWND, mask: ::std::os::raw::c_int)>,
    pub GetTempPath:
        Option<unsafe extern "C" fn(sz: ::std::os::raw::c_int, buf: *mut ::std::os::raw::c_char)>,
    pub SWELL_initargs: Option<
        unsafe extern "C" fn(
            argc: *mut ::std::os::raw::c_int,
            argv: *mut *mut *mut ::std::os::raw::c_char,
        ),
    >,
    pub SWELL_RunMessageLoop: Option<extern "C" fn()>,
    pub SWELL_CreateXBridgeWindow: Option<
        unsafe extern "C" fn(
            viewpar: root::HWND,
            wref: *mut *mut ::std::os::raw::c_void,
            arg1: *mut root::RECT,
        ) -> root::HWND,
    >,
    pub SWELL_GenerateGUID: Option<unsafe extern "C" fn(g: *mut ::std::os::raw::c_void) -> bool>,
    pub EnumChildWindows: Option<
        unsafe extern "C" fn(
            hwnd: root::HWND,
            cwEnumFunc: ::std::option::Option<
                unsafe extern "C" fn(arg1: root::HWND, arg2: root::LPARAM) -> root::BOOL,
            >,
            lParam: root::LPARAM,
        ) -> root::BOOL,
    >,
    pub SWELL_IsGroupBox: Option<unsafe extern "C" fn(arg1: root::HWND) -> root::BOOL>,
    pub SWELL_IsButton: Option<unsafe extern "C" fn(arg1: root::HWND) -> root::BOOL>,
    pub SWELL_IsStaticText: Option<unsafe extern "C" fn(arg1: root::HWND) -> root::BOOL>,
    pub SWELL_GetDesiredControlSize:
        Option<unsafe extern "C" fn(hwnd: root::HWND, r: *mut root::RECT)>,
    pub AddFontResourceEx: Option<
        unsafe extern "C" fn(
            str: root::LPCTSTR,
            fl: root::DWORD,
            pdv: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub SWELL_Register_Cursor_Resource: Option<
        unsafe extern "C" fn(
            idx: *const ::std::os::raw::c_char,
            name: *const ::std::os::raw::c_char,
            hotspot_x: ::std::os::raw::c_int,
            hotspot_y: ::std::os::raw::c_int,
        ),
    >,
    pub SWELL_ChooseColor: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            arg2: *mut ::std::os::raw::c_int,
            ncustom: ::std::os::raw::c_int,
            custom: *mut ::std::os::raw::c_int,
        ) -> bool,
    >,
    pub SWELL_ChooseFont:
        Option<unsafe extern "C" fn(arg1: root::HWND, arg2: *mut root::LOGFONT) -> bool>,
    pub IsWindowEnabled: Option<unsafe extern "C" fn(arg1: root::HWND) -> bool>,
    pub GetClassName: Option<
        unsafe extern "C" fn(
            arg1: root::HWND,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub SWELL_SetClassName:
        Option<unsafe extern "C" fn(arg1: root::HWND, arg2: *const ::std::os::raw::c_char)>,
    pub SWELL_osx_is_dark_mode: Option<extern "C" fn(mode: ::std::os::raw::c_int) -> bool>,
}
impl SwellFunctionPointers {
    pub(crate) const TOTAL_COUNT: u32 = 325u32;
}
#[cfg(target_family = "windows")]
mod windows {
    use crate::bindings::root;
    extern "system" {
        pub fn GetDlgItem(arg1: root::HWND, arg2: ::std::os::raw::c_int) -> root::HWND;
    }
    extern "system" {
        pub fn ShowWindow(arg1: root::HWND, arg2: ::std::os::raw::c_int);
    }
    extern "system" {
        pub fn DestroyWindow(hwnd: root::HWND);
    }
    extern "system" {
        pub fn SetDlgItemInt(
            arg1: root::HWND,
            idx: ::std::os::raw::c_int,
            val: ::std::os::raw::c_int,
            issigned: ::std::os::raw::c_int,
        ) -> root::BOOL;
    }
    extern "system" {
        pub fn GetDlgItemInt(
            arg1: root::HWND,
            idx: ::std::os::raw::c_int,
            translated: *mut root::BOOL,
            issigned: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "system" {
        pub fn CheckDlgButton(
            hwnd: root::HWND,
            idx: ::std::os::raw::c_int,
            check: ::std::os::raw::c_int,
        );
    }
    extern "system" {
        pub fn IsDlgButtonChecked(
            hwnd: root::HWND,
            idx: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "system" {
        pub fn EnableWindow(hwnd: root::HWND, enable: ::std::os::raw::c_int);
    }
    extern "system" {
        pub fn SetFocus(hwnd: root::HWND);
    }
    extern "system" {
        pub fn GetFocus() -> root::HWND;
    }
    extern "system" {
        pub fn SetForegroundWindow(hwnd: root::HWND);
    }
    extern "system" {
        pub fn GetForegroundWindow() -> root::HWND;
    }
    extern "system" {
        pub fn SetCapture(hwnd: root::HWND) -> root::HWND;
    }
    extern "system" {
        pub fn GetCapture() -> root::HWND;
    }
    extern "system" {
        pub fn ReleaseCapture();
    }
    extern "system" {
        pub fn IsChild(hwndParent: root::HWND, hwndChild: root::HWND) -> ::std::os::raw::c_int;
    }
    extern "system" {
        pub fn GetParent(hwnd: root::HWND) -> root::HWND;
    }
    extern "system" {
        pub fn SetParent(hwnd: root::HWND, newPar: root::HWND) -> root::HWND;
    }
    extern "system" {
        pub fn GetWindow(hwnd: root::HWND, what: ::std::os::raw::c_int) -> root::HWND;
    }
    extern "system" {
        pub fn EnumWindows(
            proc_: ::std::option::Option<
                unsafe extern "C" fn(arg1: root::HWND, arg2: root::LPARAM) -> root::BOOL,
            >,
            lp: root::LPARAM,
        ) -> root::BOOL;
    }
    extern "system" {
        pub fn ClientToScreen(hwnd: root::HWND, p: *mut root::POINT);
    }
    extern "system" {
        pub fn ScreenToClient(hwnd: root::HWND, p: *mut root::POINT);
    }
    extern "system" {
        pub fn GetWindowRect(hwnd: root::HWND, r: *mut root::RECT) -> bool;
    }
    extern "system" {
        pub fn GetClientRect(hwnd: root::HWND, r: *mut root::RECT);
    }
    extern "system" {
        pub fn WindowFromPoint(p: root::POINT) -> root::HWND;
    }
    extern "system" {
        pub fn SetWindowPos(
            hwnd: root::HWND,
            unused: root::HWND,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            cx: ::std::os::raw::c_int,
            cy: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        );
    }
    extern "system" {
        pub fn InvalidateRect(
            hwnd: root::HWND,
            r: *const root::RECT,
            eraseBk: ::std::os::raw::c_int,
        ) -> root::BOOL;
    }
    extern "system" {
        pub fn ScrollWindow(
            hwnd: root::HWND,
            xamt: ::std::os::raw::c_int,
            yamt: ::std::os::raw::c_int,
            lpRect: *const root::RECT,
            lpClipRect: *const root::RECT,
        ) -> root::BOOL;
    }
    extern "system" {
        pub fn IsWindowVisible(hwnd: root::HWND) -> bool;
    }
    extern "system" {
        pub fn IsWindow(hwnd: root::HWND) -> bool;
    }
    extern "system" {
        pub fn SetTimer(
            hwnd: root::HWND,
            timerid: root::UINT_PTR,
            rate: root::UINT,
            tProc: root::TIMERPROC,
        ) -> root::UINT_PTR;
    }
    extern "system" {
        pub fn KillTimer(hwnd: root::HWND, timerid: root::UINT_PTR) -> root::BOOL;
    }
    extern "system" {
        pub fn CreatePopupMenu() -> root::HMENU;
    }
    extern "system" {
        pub fn DestroyMenu(hMenu: root::HMENU);
    }
    extern "system" {
        pub fn GetSubMenu(hMenu: root::HMENU, pos: ::std::os::raw::c_int) -> root::HMENU;
    }
    extern "system" {
        pub fn GetMenuItemCount(hMenu: root::HMENU) -> ::std::os::raw::c_int;
    }
    extern "system" {
        pub fn GetMenuItemID(
            hMenu: root::HMENU,
            pos: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    extern "system" {
        pub fn EnableMenuItem(
            hMenu: root::HMENU,
            idx: ::std::os::raw::c_int,
            en: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "system" {
        pub fn DeleteMenu(
            hMenu: root::HMENU,
            idx: ::std::os::raw::c_int,
            flag: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "system" {
        pub fn CheckMenuItem(
            hMenu: root::HMENU,
            idx: ::std::os::raw::c_int,
            chk: ::std::os::raw::c_int,
        ) -> bool;
    }
    extern "system" {
        pub fn DrawMenuBar(arg1: root::HWND);
    }
    extern "system" {
        pub fn TrackPopupMenu(
            hMenu: root::HMENU,
            flags: ::std::os::raw::c_int,
            xpos: ::std::os::raw::c_int,
            ypos: ::std::os::raw::c_int,
            resvd: ::std::os::raw::c_int,
            hwnd: root::HWND,
            r: *const root::RECT,
        ) -> ::std::os::raw::c_int;
    }
    extern "system" {
        pub fn SetMenu(hwnd: root::HWND, menu: root::HMENU) -> root::BOOL;
    }
    extern "system" {
        pub fn GetMenu(hwnd: root::HWND) -> root::HMENU;
    }
    extern "system" {
        pub fn EndDialog(arg1: root::HWND, arg2: ::std::os::raw::c_int);
    }
    extern "system" {
        pub fn GetAsyncKeyState(key: ::std::os::raw::c_int) -> root::WORD;
    }
    extern "system" {
        pub fn GetCursorPos(pt: *mut root::POINT);
    }
    extern "system" {
        pub fn GetMessagePos() -> root::DWORD;
    }
    extern "system" {
        pub fn OpenClipboard(hwndDlg: root::HWND) -> bool;
    }
    extern "system" {
        pub fn CloseClipboard();
    }
    extern "system" {
        pub fn GetClipboardData(type_: root::UINT) -> root::HANDLE;
    }
    extern "system" {
        pub fn EmptyClipboard();
    }
    extern "system" {
        pub fn SetClipboardData(type_: root::UINT, h: root::HANDLE);
    }
    extern "system" {
        pub fn EnumClipboardFormats(lastfmt: root::UINT) -> root::UINT;
    }
    extern "system" {
        pub fn GlobalAlloc(flags: ::std::os::raw::c_int, sz: ::std::os::raw::c_int)
        -> root::HANDLE;
    }
    extern "system" {
        pub fn GlobalLock(h: root::HANDLE) -> *mut ::std::os::raw::c_void;
    }
    extern "system" {
        pub fn GlobalUnlock(h: root::HANDLE);
    }
    extern "system" {
        pub fn CreateSolidBrush(col: ::std::os::raw::c_int) -> root::HBRUSH;
    }
    extern "system" {
        pub fn SetTextColor(ctx: root::HDC, col: ::std::os::raw::c_int);
    }
    extern "system" {
        pub fn SetBkColor(ctx: root::HDC, col: ::std::os::raw::c_int);
    }
    extern "system" {
        pub fn SetBkMode(ctx: root::HDC, col: ::std::os::raw::c_int);
    }
    extern "system" {
        pub fn CreateIconIndirect(iconinfo: *mut root::ICONINFO) -> root::HICON;
    }
    extern "system" {
        pub fn BitBlt(
            hdcOut: root::HDC,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            hdcIn: root::HDC,
            xin: ::std::os::raw::c_int,
            yin: ::std::os::raw::c_int,
            mode: ::std::os::raw::c_int,
        );
    }
    extern "system" {
        pub fn StretchBlt(
            hdcOut: root::HDC,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            w: ::std::os::raw::c_int,
            h: ::std::os::raw::c_int,
            hdcIn: root::HDC,
            xin: ::std::os::raw::c_int,
            yin: ::std::os::raw::c_int,
            srcw: ::std::os::raw::c_int,
            srch: ::std::os::raw::c_int,
            mode: ::std::os::raw::c_int,
        );
    }
    extern "system" {
        pub fn GetSysColor(idx: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "system" {
        pub fn BeginPaint(arg1: root::HWND, arg2: *mut root::PAINTSTRUCT) -> root::HDC;
    }
    extern "system" {
        pub fn EndPaint(arg1: root::HWND, arg2: *mut root::PAINTSTRUCT) -> root::BOOL;
    }
    extern "system" {
        pub fn GetDC(arg1: root::HWND) -> root::HDC;
    }
    extern "system" {
        pub fn GetWindowDC(arg1: root::HWND) -> root::HDC;
    }
    extern "system" {
        pub fn ReleaseDC(arg1: root::HWND, arg2: root::HDC);
    }
    extern "system" {
        pub fn GetSystemMetrics(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    }
    extern "system" {
        pub fn EnumChildWindows(
            hwnd: root::HWND,
            cwEnumFunc: ::std::option::Option<
                unsafe extern "C" fn(arg1: root::HWND, arg2: root::LPARAM) -> root::BOOL,
            >,
            lParam: root::LPARAM,
        ) -> root::BOOL;
    }
    extern "system" {
        pub fn IsWindowEnabled(arg1: root::HWND) -> bool;
    }
}
